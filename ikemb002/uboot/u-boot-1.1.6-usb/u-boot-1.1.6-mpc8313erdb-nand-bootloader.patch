From 34a5fc9b4c1a29517be184529f52dc949dd2ea37 Mon Sep 17 00:00:00 2001
From: tanya <tanya.jiang@test.net>
Date: Tue, 3 Apr 2007 16:52:56 +0800
Subject: [PATCH] Add nand bootloader /update readme/ leave reset

---
 Makefile                              |   17 +-
 board/mpc8313erdb/Makefile            |    2 +-
 board/mpc8313erdb/config.mk           |    4 +
 board/mpc8313erdb/mpc8313erdb.c       |   85 ------
 board/mpc8313erdb/nand_boot.c         |  469 +++++++++++++++++++++++++++++++++
 board/mpc8313erdb/nand_ecc.c          |  214 +++++++++++++++
 board/mpc8313erdb/sdram.c             |  129 +++++++++
 board/mpc8313erdb/u-boot-nand.lds     |  138 ++++++++++
 cpu/mpc83xx/start.S                   |  260 ++++++++++++++-----
 doc/README.mpc8313erdb                |  109 ++++++++-
 include/configs/MPC8313ERDB.h         |   84 ++++++-
 nand_spl/board/mpc8313erdb/Makefile   |   90 +++++++
 nand_spl/board/mpc8313erdb/config.mk  |   47 ++++
 nand_spl/board/mpc8313erdb/u-boot.lds |   64 +++++
 14 files changed, 1545 insertions(+), 167 deletions(-)
 create mode 100644 board/mpc8313erdb/nand_boot.c
 create mode 100644 board/mpc8313erdb/nand_ecc.c
 create mode 100644 board/mpc8313erdb/sdram.c
 create mode 100644 board/mpc8313erdb/u-boot-nand.lds
 create mode 100644 nand_spl/board/mpc8313erdb/Makefile
 create mode 100644 nand_spl/board/mpc8313erdb/config.mk
 create mode 100644 nand_spl/board/mpc8313erdb/u-boot.lds

diff --git a/Makefile b/Makefile
index db2b9a1..e801c73 100644
--- a/Makefile
+++ b/Makefile
@@ -1621,8 +1621,21 @@ MPC8360EMDS_SLAVE_config:	unconfig
 MPC8349ITX_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) ppc mpc83xx mpc8349itx
 
-MPC8313ERDB_config:	unconfig
-	@$(MKCONFIG) $(@:_config=) ppc mpc83xx mpc8313erdb
+MPC8313ERDB_config \
+MPC8313ERDB_NAND_config:	unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)nand_spl
+	@mkdir -p $(obj)board/mpc8313erdb
+	@echo "" >$(obj)include/config.h ; \
+	if [ "$(findstring _NAND_,$@)" ] ; then \
+		echo -n "... NAND " ; \
+		echo "#define CONFIG_NAND_U_BOOT" >> $(obj)include/config.h ; \
+	fi ;
+	@$(MKCONFIG) -a MPC8313ERDB ppc mpc83xx mpc8313erdb;\
+	if [ "$(findstring _NAND_,$@)" ] ; then \
+		echo "TEXT_BASE = 0x01000000" > $(obj)board/mpc8313erdb/config.tmp ; \
+		echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk ; \
+	fi ;
 
 #########################################################################
 ## MPC85xx Systems
diff --git a/board/mpc8313erdb/Makefile b/board/mpc8313erdb/Makefile
index fb7c5e4..870719a 100644
--- a/board/mpc8313erdb/Makefile
+++ b/board/mpc8313erdb/Makefile
@@ -25,7 +25,7 @@ include $(TOPDIR)/config.mk
 
 LIB	= $(obj)lib$(BOARD).a
 
-COBJS	:= $(BOARD).o pci.o nand.o
+COBJS	:= $(BOARD).o sdram.o pci.o nand.o
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS))
diff --git a/board/mpc8313erdb/config.mk b/board/mpc8313erdb/config.mk
index c10e810..0817abf 100644
--- a/board/mpc8313erdb/config.mk
+++ b/board/mpc8313erdb/config.mk
@@ -25,4 +25,8 @@
 # MPC8313ERDB
 #
 
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
 TEXT_BASE  =   0xFE000000
+endif
diff --git a/board/mpc8313erdb/mpc8313erdb.c b/board/mpc8313erdb/mpc8313erdb.c
index ce447b3..eb9cc75 100644
--- a/board/mpc8313erdb/mpc8313erdb.c
+++ b/board/mpc8313erdb/mpc8313erdb.c
@@ -37,8 +37,6 @@
 #if defined(CONFIG_SPD_EEPROM)
 #include <spd_sdram.h>
 #endif
-int fixed_sdram(void);
-void sdram_init(void);
 
 int board_early_init_f(void)
 {
@@ -47,89 +45,6 @@ int board_early_init_f(void)
 
 #define ns2clk(ns) (ns / (1000000000 / CONFIG_83XX_CLKIN) + 1)
 
-long int initdram(int board_type)
-{
-	volatile immap_t *im = (immap_t *) CFG_IMMR;
-	volatile lbus83xx_t *lbc= &im->lbus;
-
-	u32 msize = 0;
-
-	if ((im->sysconf.immrbar & IMMRBAR_BASE_ADDR) != (u32) im)
-		return -1;
-
-	puts("Initializing\n");
-
-	/* DDR SDRAM - Main SODIMM */
-	im->sysconf.ddrlaw[0].bar = CFG_DDR_BASE & LAWBAR_BAR;
-#if defined(CONFIG_SPD_EEPROM)
-	msize = spd_sdram();
-#else
-	msize = fixed_sdram();
-#endif
-
-	/* Local Bus setup lbcr and mrtpr */
-	lbc->lbcr = CFG_LBC_LBCR;
-	lbc->mrtpr = CFG_LBC_MRTPR;
-	asm("sync");
-
-	puts("   DDR RAM: ");
-	/* return total bus SDRAM size(bytes)  -- DDR */
-	return (msize * 1024 * 1024);
-}
-
-#if !defined(CONFIG_SPD_EEPROM)
-/*************************************************************************
- *  fixed sdram init -- doesn't use serial presence detect.
- ************************************************************************/
-int fixed_sdram(void)
-{
-	volatile immap_t *im = (immap_t *) CFG_IMMR;
-	u32 msize = 0;
-	u32 ddr_size;
-	u32 ddr_size_log2;
-
-	msize = CFG_DDR_SIZE;
-	for (ddr_size = msize << 20, ddr_size_log2 = 0;
-	     (ddr_size > 1);
-	     ddr_size = ddr_size >> 1, ddr_size_log2++) {
-		if (ddr_size & 1) {
-			return -1;
-		}
-	}
-	im->sysconf.ddrlaw[0].bar = ((CFG_DDR_SDRAM_BASE >> 12) & 0xfffff);
-	im->sysconf.ddrlaw[0].ar = LAWAR_EN | ((ddr_size_log2 - 1) & LAWAR_SIZE);
-	im->sysconf.ddrcdr = CFG_DDRCDR;
-
-#if (CFG_DDR_SIZE != 128)
-#warning Currenly any ddr size other than 128 is not supported
-#endif
-	im->ddr.csbnds[0].csbnds = 0x00000007;
-	im->ddr.cs_config[0] = CFG_DDR_CONFIG;
-
-	/* currently we use only one CS, so disable the other banks */
-	im->ddr.cs_config[1] = 0;
-	im->ddr.cs_config[2] = 0;
-	im->ddr.cs_config[3] = 0;
-
-	im->ddr.sdram_clk_cntl = CFG_DDR_CLK_CNTL;
-	im->ddr.timing_cfg_3 = CFG_DDR_TIMING_3;
-	im->ddr.timing_cfg_1 = CFG_DDR_TIMING_1;
-	im->ddr.timing_cfg_2 = CFG_DDR_TIMING_2;
-	im->ddr.timing_cfg_0 = CFG_DDR_TIMING_0;
-	im->ddr.sdram_cfg = CFG_SDRAM_CFG;
-	im->ddr.sdram_cfg2 = CFG_SDRAM_CFG2;
-	im->ddr.sdram_mode = CFG_DDR_MODE;
-	im->ddr.sdram_mode_2 = CFG_DDR_MODE_2;
-
-	im->ddr.sdram_interval = CFG_DDR_INTERVAL;
-	udelay(200);
-
-	/* enable DDR controller */
-	im->ddr.sdram_cfg |= SDRAM_CFG_MEM_EN;
-	return msize;
-}
-#endif /*!CFG_SPD_EEPROM */
-
 int checkboard(void)
 {
 	uint*	led_ptr;
diff --git a/board/mpc8313erdb/nand_boot.c b/board/mpc8313erdb/nand_boot.c
new file mode 100644
index 0000000..a8df7a1
--- /dev/null
+++ b/board/mpc8313erdb/nand_boot.c
@@ -0,0 +1,469 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc.
+ * 
+ * Origin from MPC8313EMDS of Nick.Spence@freescale.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <common.h>
+#include <mpc83xx.h>
+#include <ns16550.h>
+#include <nand.h>
+#include <asm/processor.h>
+
+/* NAND ECC checking method - 0 = no hardware ECC check */
+#define NAND_HARD_ECC ((CFG_NAND_BR0_PRELIM >> BR_DECC_SHIFT) & 3)
+
+/* NAND Page Size : 0 = small page (512 bytes ), 1 = large page (2048 bytes) */
+#define NAND_PGS ((CFG_NAND_OR0_PRELIM >> OR_FCM_PGS_SHIFT) & 1)
+
+/* Timeout in case FCM does not complete */
+#define NAND_TIMEOUT	 (1000000)
+
+/* Delay before restarting after a fatal u-boot error */
+#define RESTART_DELAY	 (0x4000000)
+
+/* Error codes returned from nand_read_next_block()                */
+#define NAND_OK          (1)	/* read block okay                 */
+#define NAND_BAD_BLOCK   (0)	/* block marked bad - skip block   */
+#define NAND_ERR_TIMEOUT (-1)	/* timeout error - fatal error     */
+#define NAND_ERR_ECC     (-2)	/* uncorrectable ecc - fatal error */
+
+/* Macros to control selected serial port */
+#if CONFIG_CONS_INDEX == 1 && defined(CFG_NS16550_COM1)
+#define NS16550_COM ((NS16550_t)CFG_NS16550_COM1)
+#elif CONFIG_CONS_INDEX == 2 && defined(CFG_NS16550_COM2)
+#define NS16550_COM ((NS16550_t)CFG_NS16550_COM2)
+#else
+#warning  "*****************************"
+#warning  "** No console port defined **"
+#warning  "*****************************"
+#define NS16550_COM ((NS16550_t)0)
+#define CFG_NAND_BOOT_QUIET
+#endif /* CONFIG_CONS_INDEX */
+
+/* Quiet Boot - only prints fatal error messages */
+#if defined(CFG_NAND_BOOT_QUIET)
+#define status_putc(c) { while (0); }
+#define status_puts(s) { while (0); }
+#else
+#define status_putc(c) { putc(c); }
+#define status_puts(s) { puts(s); }
+#endif /* CFG_NAND_BOOT_QUIET */
+
+#if !(NAND_HARD_ECC)
+const u_char ecc_pos[] = {
+#if (NAND_PGS)
+	40, 41, 42, 43, 44, 45, 46, 47,
+	48, 49, 50, 51, 52, 53, 54, 55,
+	56, 57, 58, 59, 60, 61, 62, 63
+#else
+	0, 1, 2, 3, 6, 7
+#endif /* NAND_PGS */
+};
+#endif /* !(NAND_HARD_ECC) */
+
+/* u-boot version string from start.S */
+extern char version_string[];
+
+/* nand_ecc.c */
+extern int nand_correct_data (u_char * dat, const u_char * ecc_pos, int blocks);
+
+/* reset board */
+static
+void reset (void)
+{
+	int ctr;
+	ulong msr;
+#ifndef MPC83xx_RESET
+	ulong addr;
+#endif
+
+	volatile immap_t *immap = (immap_t *) CFG_IMMR;
+
+	/* add delay before reseting */
+	ctr = RESTART_DELAY;
+	while (ctr--) ;
+
+#ifdef MPC83xx_RESET
+	/* Interrupts and MMU off */
+	__asm__ __volatile__ ("mfmsr    %0":"=r" (msr):);
+
+	msr &= ~( MSR_EE | MSR_IR | MSR_DR);
+	__asm__ __volatile__ ("mtmsr    %0"::"r" (msr));
+
+	/* enable Reset Control Reg */
+	immap->reset.rpr = 0x52535445;
+	__asm__ __volatile__ ("sync");
+	__asm__ __volatile__ ("isync");
+
+	/* confirm Reset Control Reg is enabled */
+	while(!((immap->reset.rcer) & RCER_CRE));
+
+	/* perform reset, only one bit */
+	immap->reset.rcr = RCR_SWHR;
+
+#else   /* ! MPC83xx_RESET */
+
+	immap->reset.rmr = RMR_CSRE;    /* Checkstop Reset enable */
+
+	/* Interrupts and MMU off */
+	__asm__ __volatile__ ("mfmsr    %0":"=r" (msr):);
+
+	msr &= ~(MSR_ME | MSR_EE | MSR_IR | MSR_DR);
+	__asm__ __volatile__ ("mtmsr    %0"::"r" (msr));
+
+	/*
+	 * Trying to execute the next instruction at a non-existing address
+	 * should cause a machine check, resulting in reset
+	 */
+	addr = CFG_RESET_ADDRESS;
+	((void (*)(void)) addr) ();
+#endif  /* MPC83xx_RESET */
+}
+
+#define LCRVAL LCR_8N1				/* 8 data, 1 stop, no parity */
+#define MCRVAL (MCR_DTR | MCR_RTS)		/* RTS/DTR */
+#define FCRVAL (FCR_FIFO_EN | FCR_RXSR | FCR_TXSR) /* Clear & enable FIFOs */
+
+static
+void NS16550a_init (int baud_divisor)
+{
+	if (NS16550_COM) {
+		NS16550_COM->ier = 0x00;
+		NS16550_COM->lcr = LCR_BKSE | LCRVAL;
+		NS16550_COM->dll = baud_divisor & 0xff;
+		NS16550_COM->dlm = (baud_divisor >> 8) & 0xff;
+		NS16550_COM->lcr = LCRVAL;
+		NS16550_COM->mcr = MCRVAL;
+		NS16550_COM->fcr = FCRVAL;
+	}
+}
+
+/* print a single character, with an extra line feed for return characters */
+void putc (const char c)
+{
+	if (NS16550_COM) {
+		if (c == '\n') {
+			while ((NS16550_COM->lsr & LSR_THRE) == 0);
+			NS16550_COM->thr = '\r';
+		}
+		while ((NS16550_COM->lsr & LSR_THRE) == 0);
+		NS16550_COM->thr = c;
+	}
+}
+
+/* print an entire null terminated string */
+void puts (const char *s)
+{
+	while (*s) {
+		putc (*s++);
+	}
+}
+
+/* read the next block from NAND flash and store it at the supplied address
+ *
+ * return values:
+ *  NAND_OK          - block was successfully read and copied to the destination
+ *  NAND_BAD_BLOCK   - block was marked bad so should be skipped
+ *  NAND_ERR_TIMEOUT - page read did not complete (fatal error)
+ *  NAND_ERR_ECC     - uncorrectable ECC (fatal error)
+ */
+static
+int nand_read_next_block (unsigned int *dst)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc = &im->lbus;
+	int buf_num;
+	int page;
+	unsigned char *srcc;
+	unsigned int *src;
+	int ecc_err;
+	int ctr;
+	unsigned int status;
+#if !(NAND_HARD_ECC)
+	int ecc_cnt;
+	char ecc_char;
+
+	ecc_cnt = 0;
+#endif /* !(NAND_HARD_ECC) */
+
+	ecc_err = 0;
+	srcc = 0;
+
+	/* Enable FCM detection of timeouts, ECC errors and completion */
+	lbc->ltedr = 0;
+
+	lbc->fbcr = 0;		/* read entire page to enable ECC */
+	lbc->fbar++;		/* read next block, follows boot loaded block */
+#if (NAND_PGS)
+	lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+	    (FIR_OP_CA << FIR_OP1_SHIFT) |
+	    (FIR_OP_PA << FIR_OP2_SHIFT) |
+	    (FIR_OP_CW1 << FIR_OP3_SHIFT) |
+	    (FIR_OP_RBW << FIR_OP4_SHIFT);
+#else
+	lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+	    (FIR_OP_CA << FIR_OP1_SHIFT) |
+	    (FIR_OP_PA << FIR_OP2_SHIFT) |
+	    (FIR_OP_RBW << FIR_OP3_SHIFT);
+#endif /* NAND_PGS */
+	lbc->fcr = (NAND_CMD_READ0 << FCR_CMD0_SHIFT) |
+	    (NAND_CMD_READSTART << FCR_CMD1_SHIFT);
+
+	/* read in each page of the block */
+	for (page = 0; page < (CFG_NAND_BLOCK_SIZE / CFG_NAND_PAGE_SIZE);
+	     page++) {
+		if (NAND_PGS) {
+			lbc->fpar = ((page << FPAR_LP_PI_SHIFT) & FPAR_LP_PI);
+			buf_num = (page & 1) << 2;
+		} else {
+			lbc->fpar = ((page << FPAR_SP_PI_SHIFT) & FPAR_SP_PI);
+			buf_num = page & 7;
+		}
+		lbc->fmr = CFG_NAND_FMR | 2;
+
+		/* clear event registers */
+		lbc->ltesr = lbc->ltesr;
+		lbc->lteatr = 0;
+
+		/* execute special operation on bank 0 */
+		lbc->lsor = 0;
+		asm ("sync");
+
+		/* copy previous page to RAM */
+		if (srcc) {
+#if !(NAND_HARD_ECC)
+			status =
+			    nand_correct_data (srcc, ecc_pos,
+					       sizeof (ecc_pos) / 3);
+			ecc_cnt += status;
+			if (status < 0)
+				ecc_err = 1;
+#endif /* !(NAND_HARD_ECC) */
+			src = (unsigned int *)srcc;
+			for (ctr = CFG_NAND_PAGE_SIZE / sizeof (unsigned int);
+			     ctr; ctr--) {
+				*(dst++) = *(src++);
+			}
+		}
+
+		/* store the source address for the next page */
+		srcc = (unsigned char *)((CFG_NAND_BR0_PRELIM & BR_BA) +
+					 (buf_num * 1024));
+
+		/* wait for FCM complete flag or timeout */
+		status = 0;
+		for (ctr = NAND_TIMEOUT; ctr; ctr--) {
+			status = lbc->ltesr;
+			if (status) {
+				break;
+			}
+		}
+
+		/* check for timeout or hardware ECC errors */
+		if (status != LTESR_CC) {
+#if (NAND_HARD_ECC)
+			if (status & LTESR_PAR) {
+				ecc_err = 1;
+			} else
+#endif /* NAND_HARD_ECC */
+			{
+				status_putc ('T');
+				return NAND_ERR_TIMEOUT;
+			}
+		}
+
+		/* Check if the block is marked as bad */
+		if (page < 2) {
+			if (srcc[CFG_NAND_PAGE_SIZE + CFG_NAND_BAD_BLOCK_POS] !=
+			    0xFF) {
+				status_putc ('B');
+				return NAND_BAD_BLOCK;
+			}
+		}
+	}
+
+	/* copy last page to RAM */
+#if !(NAND_HARD_ECC)
+	status = nand_correct_data (srcc, ecc_pos, sizeof (ecc_pos) / 3);
+	ecc_cnt += status;
+	if (status < 0)
+		ecc_err = 1;
+#endif /* !(NAND_HARD_ECC) */
+	src = (unsigned int *)srcc;
+	for (ctr = CFG_NAND_PAGE_SIZE / sizeof (unsigned int); ctr; ctr--) {
+		*(dst++) = *(src++);
+	}
+
+	/* abort if any of the pages had uncorrectable errors */
+	if (ecc_err && (page > 1)) {
+		status_putc ('U');
+		return NAND_ERR_ECC;
+	}
+#if (NAND_HARD_ECC)
+	status_putc ('.');
+#else
+#ifdef CFG_NAND_BOOT_SHOW_ECC_NONE
+	ecc_char = '.';
+#else
+	if (ecc_cnt <= 0) {
+		ecc_char = '.';
+#ifdef CFG_NAND_BOOT_SHOW_ECC_NUM
+	} else if (ecc_cnt <= 9) {
+		ecc_char = '0' + ecc_cnt;
+	} else {
+		ecc_char = 'a' + ecc_cnt - 10;
+#else
+	} else {
+		ecc_char = 'c';
+#endif /* CFG_NAND_BOOT_SHOW_ECC_NUM */
+	}
+#endif /* CFG_NAND_BOOT_SHOW_ECC_NONE */
+	status_putc (ecc_char);
+#endif /* NAND_HARD_ECC */
+
+	return NAND_OK;		/* block read completed ok */
+}
+
+/* initial C code called from start.S prior to relocating code to DDR
+ *
+ * This performs minimal CPU initailization, DDR initialization, a few
+ * print statements and the calls relocate_code() to copy the code from
+ * the NAND flash buffer to DDR.
+ */
+void cpu_init_f (volatile immap_t * im)
+{
+	u8 spmf;
+	u8 clkin_div;
+	u32 csb_clk;
+
+	/* RMR - Reset Mode Register - enable checkstop reset enable */
+	im->reset.rmr = (RMR_CSRE & (1 << RMR_CSRE_SHIFT));
+
+	/* LCRR - Clock Ratio Register - set up local bus timing */
+	im->lbus.lcrr = CFG_LCRR;
+
+#if defined(CFG_NAND_BR0_PRELIM)  \
+	&& defined(CFG_NAND_OR0_PRELIM) \
+	&& defined(CFG_NAND_LBLAWBAR0_PRELIM) \
+	&& defined(CFG_NAND_LBLAWAR0_PRELIM)
+	im->lbus.bank[0].br = CFG_NAND_BR0_PRELIM;
+	im->lbus.bank[0].or = CFG_NAND_OR0_PRELIM;
+	im->sysconf.lblaw[0].bar = CFG_NAND_LBLAWBAR0_PRELIM;
+	im->sysconf.lblaw[0].ar = CFG_NAND_LBLAWAR0_PRELIM;
+#else
+#error  CFG_NAND_BR0_PRELIM, CFG_NAND_OR0_PRELIM, CFG_NAND_LBLAWBAR0_PRELIM & CFG_NAND_LBLAWAR0_PRELIM must be defined
+#endif
+	clkin_div = ((im->clk.spmr & SPMR_CKID) >> SPMR_CKID_SHIFT);
+	spmf = ((im->reset.rcwl & RCWL_SPMF) >> RCWL_SPMF_SHIFT);
+
+	if (im->reset.rcwh & HRCWH_PCI_HOST) {
+#if defined(CONFIG_83XX_CLKIN)
+		csb_clk = CONFIG_83XX_CLKIN * spmf;
+#else
+		csb_clk = 0;
+#endif /* CONFIG_83XX_CLKIN */
+	} else {
+#if defined(CONFIG_83XX_PCICLK)
+		csb_clk = CONFIG_83XX_PCICLK * spmf * (1 + clkin_div);
+#else
+		csb_clk = 0;
+#endif /* CONFIG_83XX_PCICLK */
+	}
+
+	/* initialize selected port with appropriate baud rate */
+	NS16550a_init (csb_clk / 16 / CONFIG_BAUDRATE);
+
+	status_puts ("\nNAND SPL - ");
+	status_puts ((char *)(&version_string));
+
+	/* board specific DDR initialization */
+	initdram (0);
+
+	/* copy code to DDR and jump to it - this should not return */
+	/* NOTE - code has to be copied out of NAND buffer before
+	 * other blocks can be read.
+	 */
+	relocate_code (CFG_NAND_RELOC + 0x10000, 0, CFG_NAND_RELOC);
+
+	/* should never get here */
+	puts ("\nRelocate failed\n");
+
+	/* delay then restart */
+	reset ();
+}
+
+/* called after code is moved to DDR, to complete boot loading */
+void board_init_r (gd_t * id, ulong dest_addr)
+{
+	int blockcopy_count;
+	unsigned char *dst;
+	void (*uboot) (void* dummy, void* immr);
+	int ret;
+
+	icache_enable ();	/* faster execution */
+
+	status_puts ("\nLoading from NAND : ");
+
+	/*
+	 * Load U-Boot image from NAND into RAM
+	 */
+	dst = (unsigned char *)CFG_NAND_U_BOOT_DST;
+	blockcopy_count = ((CFG_NAND_U_BOOT_SIZE + CFG_NAND_BLOCK_SIZE - 1)
+			   / CFG_NAND_BLOCK_SIZE);
+
+	while (blockcopy_count) {
+		ret = nand_read_next_block ((unsigned int *)dst);
+		switch (ret) {
+		case NAND_OK:
+			/* advance to the next block */
+			dst += CFG_NAND_BLOCK_SIZE;
+			blockcopy_count--;
+			break;
+		case NAND_BAD_BLOCK:
+			/* skip bad block */
+			break;
+		default:	/* fatal error */
+#if defined(CFG_NAND_BOOT_QUIET)
+			puts ("\nNAND SPL - ");
+#else
+			putc ('\n');
+#endif /* CFG_NAND_BOOT_QUIET */
+			if (ret == NAND_ERR_TIMEOUT)
+				puts ("**FATAL** : NAND Flash operation timeout\n");
+			else
+				puts ("**FATAL** : uncorrectable ECC Error\n");
+
+			/* delay then restart */
+			reset ();
+			break;
+		}
+	}
+	
+	/*
+	 * Jump to U-Boot image
+	 */
+	uboot = (void (*)(void* dummy, void* immr))CFG_NAND_U_BOOT_START;
+	(*uboot) (NULL, (void*) CFG_IMMR);
+}
+
+
diff --git a/board/mpc8313erdb/nand_ecc.c b/board/mpc8313erdb/nand_ecc.c
new file mode 100644
index 0000000..87db359
--- /dev/null
+++ b/board/mpc8313erdb/nand_ecc.c
@@ -0,0 +1,214 @@
+/*
+ * This file was copied from drivers/nand/nand_ecc.c and optimized to reduce
+ * the memory size and function calls to correct up to 1 bit error in each
+ * 256 byte block of data.
+ *
+ * Copyright (C) 2006, Freescale Semiconductor
+ *
+ * Copyright (C) 2000-2004 Steven J. Hill (sjhill@realitydiluted.com)
+ *                         Toshiba America Electronics Components, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 or (at your option) any
+ * later version.
+ *
+ * This file is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this file; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * As a special exception, if other files instantiate templates or use
+ * macros or inline functions from these files, or you compile these
+ * files and link them with other works to produce a work based on these
+ * files, these files do not by themselves cause the resulting work to be
+ * covered by the GNU General Public License. However the source code for
+ * these files must still be made available in accordance with section (3)
+ * of the GNU General Public License.
+ *
+ * This exception does not invalidate any other reasons why a work based on
+ * this file might be covered by the GNU General Public License.
+ */
+
+#include <common.h>
+
+/*
+ * Pre-calculated 256-way 1 byte column parity
+ */
+static const u_char nand_ecc_precalc_table[] = {
+	0x00, 0x55, 0x56, 0x03, 0x59, 0x0c, 0x0f, 0x5a, 0x5a, 0x0f, 0x0c, 0x59,
+	    0x03, 0x56, 0x55, 0x00,
+	0x65, 0x30, 0x33, 0x66, 0x3c, 0x69, 0x6a, 0x3f, 0x3f, 0x6a, 0x69, 0x3c,
+	    0x66, 0x33, 0x30, 0x65,
+	0x66, 0x33, 0x30, 0x65, 0x3f, 0x6a, 0x69, 0x3c, 0x3c, 0x69, 0x6a, 0x3f,
+	    0x65, 0x30, 0x33, 0x66,
+	0x03, 0x56, 0x55, 0x00, 0x5a, 0x0f, 0x0c, 0x59, 0x59, 0x0c, 0x0f, 0x5a,
+	    0x00, 0x55, 0x56, 0x03,
+	0x69, 0x3c, 0x3f, 0x6a, 0x30, 0x65, 0x66, 0x33, 0x33, 0x66, 0x65, 0x30,
+	    0x6a, 0x3f, 0x3c, 0x69,
+	0x0c, 0x59, 0x5a, 0x0f, 0x55, 0x00, 0x03, 0x56, 0x56, 0x03, 0x00, 0x55,
+	    0x0f, 0x5a, 0x59, 0x0c,
+	0x0f, 0x5a, 0x59, 0x0c, 0x56, 0x03, 0x00, 0x55, 0x55, 0x00, 0x03, 0x56,
+	    0x0c, 0x59, 0x5a, 0x0f,
+	0x6a, 0x3f, 0x3c, 0x69, 0x33, 0x66, 0x65, 0x30, 0x30, 0x65, 0x66, 0x33,
+	    0x69, 0x3c, 0x3f, 0x6a,
+	0x6a, 0x3f, 0x3c, 0x69, 0x33, 0x66, 0x65, 0x30, 0x30, 0x65, 0x66, 0x33,
+	    0x69, 0x3c, 0x3f, 0x6a,
+	0x0f, 0x5a, 0x59, 0x0c, 0x56, 0x03, 0x00, 0x55, 0x55, 0x00, 0x03, 0x56,
+	    0x0c, 0x59, 0x5a, 0x0f,
+	0x0c, 0x59, 0x5a, 0x0f, 0x55, 0x00, 0x03, 0x56, 0x56, 0x03, 0x00, 0x55,
+	    0x0f, 0x5a, 0x59, 0x0c,
+	0x69, 0x3c, 0x3f, 0x6a, 0x30, 0x65, 0x66, 0x33, 0x33, 0x66, 0x65, 0x30,
+	    0x6a, 0x3f, 0x3c, 0x69,
+	0x03, 0x56, 0x55, 0x00, 0x5a, 0x0f, 0x0c, 0x59, 0x59, 0x0c, 0x0f, 0x5a,
+	    0x00, 0x55, 0x56, 0x03,
+	0x66, 0x33, 0x30, 0x65, 0x3f, 0x6a, 0x69, 0x3c, 0x3c, 0x69, 0x6a, 0x3f,
+	    0x65, 0x30, 0x33, 0x66,
+	0x65, 0x30, 0x33, 0x66, 0x3c, 0x69, 0x6a, 0x3f, 0x3f, 0x6a, 0x69, 0x3c,
+	    0x66, 0x33, 0x30, 0x65,
+	0x00, 0x55, 0x56, 0x03, 0x59, 0x0c, 0x0f, 0x5a, 0x5a, 0x0f, 0x0c, 0x59,
+	    0x03, 0x56, 0x55, 0x00
+};
+
+/**
+ * nand_correct_data - [NAND Interface] Detect and correct bit error(s)
+ * @dat:	raw data read from the chip
+ * @ecc_pos:	ecc byte offsets (3 bytes per 512 data byte block)
+ * @blocks:	Number of 512 byte blocks to be processed
+ *
+ * Detect and / or correct 1 bit error per 256 byte block
+ */
+int nand_correct_data (u_char * dat, const u_char * ecc_pos, int blocks)
+{
+	u_char tmp1, tmp2;
+	u_char a, b, c, d1, d2, d3, add, bit, i;
+	u_char idx, reg1, reg2, reg3;
+	int j, ctr, ret;
+	u_char *ecc;
+
+	ecc = dat + CFG_NAND_PAGE_SIZE;
+	ctr = 0;
+	while (blocks--) {
+
+		/* Initialize variables */
+		ret = reg1 = reg2 = reg3 = 0;
+
+		/* Build up column parity */
+		for (j = 0; j < 256; j++) {
+
+			/* Get CP0 - CP5 from table */
+			idx = nand_ecc_precalc_table[dat[j]];
+			reg1 ^= (idx & 0x3f);
+
+			/* All bit XOR = 1 ? */
+			if (idx & 0x40) {
+				reg3 ^= (u_char) j;
+				reg2 ^= ~((u_char) j);
+			}
+		}
+
+		/* Create non-inverted ECC code from line parity */
+
+		/* Initialize variables */
+		a = b = c = 0x80;
+		tmp1 = tmp2 = 0;
+
+		/* Calculate first ECC byte */
+		for (i = 0; i < 4; i++) {
+			if (reg3 & a)	/* LP15,13,11,9 --> ecc_code[0] */
+				tmp1 |= b;
+			b >>= 1;
+			if (reg2 & a)	/* LP14,12,10,8 --> ecc_code[0] */
+				tmp1 |= b;
+			b >>= 1;
+			a >>= 1;
+		}
+
+		/* Calculate second ECC byte */
+		for (i = 0; i < 4; i++) {
+			if (reg3 & a)	/* LP7,5,3,1 --> ecc_code[1] */
+				tmp2 |= c;
+			c >>= 1;
+			if (reg2 & a)	/* LP6,4,2,0 --> ecc_code[1] */
+				tmp2 |= c;
+			c >>= 1;
+			a >>= 1;
+		}
+
+		/* Calculate final ECC code */
+		/* Do error detection */
+		d1 = (~tmp1) ^ ecc[*(ecc_pos++)];
+		d2 = (~tmp2) ^ ecc[*(ecc_pos++)];
+		d3 = (((~reg1) << 2) | 0x03) ^ ecc[*(ecc_pos++)];
+
+		if ((d1 | d2 | d3) != 0) {
+			/* 1 or more errors detected */
+			a = (d1 ^ (d1 >> 1)) & 0x55;
+			b = (d2 ^ (d2 >> 1)) & 0x55;
+			c = (d3 ^ (d3 >> 1)) & 0x54;
+
+			/* Found and correct single bit error in the data */
+			if ((a == 0x55) && (b == 0x55) && (c == 0x54)) {
+				a = b = c = 0x80;
+				add = 0;
+				for (i = 0; i < 4; i++) {
+					if (d1 & b)
+						add |= a;
+					b >>= 2;
+					a >>= 1;
+				}
+				for (i = 0; i < 4; i++) {
+					if (d2 & c)
+						add |= a;
+					c >>= 2;
+					a >>= 1;
+				}
+				bit = 0;
+				b = 0x04;
+				c = 0x80;
+				for (i = 0; i < 3; i++) {
+					if (d3 & c)
+						bit |= b;
+					c >>= 2;
+					b >>= 1;
+				}
+				b = 0x01;
+				a = dat[add];
+				a ^= (b << bit);
+				dat[add] = a;
+				ret = 1;
+			} else {
+				while (d1) {
+					if (d1 & 0x01)
+						ret++;
+					d1 >>= 1;
+				}
+				while (d2) {
+					if (d2 & 0x01)
+						ret++;
+					d2 >>= 1;
+				}
+				while (d3) {
+					if (d3 & 0x01)
+						ret++;
+					d3 >>= 1;
+				}
+			}
+		}
+
+		/* this page had more than 1 error so it is uncorrectable */
+		if (ret > 1)
+			return -1;
+
+		/* advance to the next page */
+		dat += 256;
+		ctr += ret;
+	}
+
+	/* return number of ECC errors that we corrected */
+	return ctr;
+}
diff --git a/board/mpc8313erdb/sdram.c b/board/mpc8313erdb/sdram.c
new file mode 100644
index 0000000..406d9da
--- /dev/null
+++ b/board/mpc8313erdb/sdram.c
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) Freescale Semiconductor, Inc. 2007. 
+ *
+ * Origin from MPC8313EMDS of Nick.Spence@freescale.com
+ *
+ * (C) Copyright 2006
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ */
+
+#include <common.h>
+#include <ioports.h>
+#include <mpc83xx.h>
+#include <asm/mmu.h>
+#include <spd.h>
+#include <command.h>
+#if defined(CONFIG_SPD_EEPROM)
+#include <spd_sdram.h>
+#endif
+
+int fixed_sdram(void);
+
+#if defined(CONFIG_NAND_SPL)
+#define puts(v) {}
+#define udelay(x) { int i,j; for (i=0; i<x; i++) for (j=0;j<10000;j++); }
+#endif
+
+long int initdram(int board_type)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+
+	u32 msize = 0;
+
+	if ((im->sysconf.immrbar & IMMRBAR_BASE_ADDR) != (u32) im)
+		return -1;
+
+	puts("Initializing\n");
+
+	/* DDR SDRAM - Main SODIMM */
+	im->sysconf.ddrlaw[0].bar = CFG_DDR_BASE & LAWBAR_BAR;
+#if defined(CONFIG_SPD_EEPROM)
+	msize = spd_sdram();
+#else
+	msize = fixed_sdram();
+#endif
+
+	/* Local Bus setup lbcr and mrtpr */
+	lbc->lbcr = CFG_LBC_LBCR;
+	lbc->mrtpr = CFG_LBC_MRTPR;
+	asm("sync");
+
+	puts("   DDR RAM: ");
+	/* return total bus SDRAM size(bytes)  -- DDR */
+	return (msize * 1024 * 1024);
+}
+
+#if !defined(CONFIG_SPD_EEPROM)
+/*************************************************************************
+ *  fixed sdram init -- doesn't use serial presence detect.
+ ************************************************************************/
+int fixed_sdram(void)
+{
+	u32 msize = CFG_DDR_SIZE;
+#if defined(CONFIG_NAND_SPL) || (!defined(CFG_RAMBOOT) && !defined(CONFIG_NAND_U_BOOT))
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	u32 ddr_size;
+	u32 ddr_size_log2;
+
+	msize = CFG_DDR_SIZE;
+
+	for (ddr_size = msize << 20, ddr_size_log2 = 0;
+	     (ddr_size > 1);
+	     ddr_size = ddr_size >> 1, ddr_size_log2++) {
+		if (ddr_size & 1) {
+			return -1;
+		}
+	}
+	im->sysconf.ddrlaw[0].bar = ((CFG_DDR_SDRAM_BASE >> 12) & 0xfffff);
+	im->sysconf.ddrlaw[0].ar = LAWAR_EN | ((ddr_size_log2 - 1) & LAWAR_SIZE);
+	im->sysconf.ddrcdr = CFG_DDRCDR;
+
+#if (CFG_DDR_SIZE != 128)
+#warning Currenly any ddr size other than 128 is not supported
+#endif
+	im->ddr.csbnds[0].csbnds = 0x00000007;
+	im->ddr.cs_config[0] = CFG_DDR_CONFIG;
+
+	/* currently we use only one CS, so disable the other banks */
+	im->ddr.cs_config[1] = 0;
+	im->ddr.cs_config[2] = 0;
+	im->ddr.cs_config[3] = 0;
+
+	im->ddr.sdram_clk_cntl = CFG_DDR_CLK_CNTL;
+	im->ddr.timing_cfg_3 = CFG_DDR_TIMING_3;
+	im->ddr.timing_cfg_1 = CFG_DDR_TIMING_1;
+	im->ddr.timing_cfg_2 = CFG_DDR_TIMING_2;
+	im->ddr.timing_cfg_0 = CFG_DDR_TIMING_0;
+	im->ddr.sdram_cfg = CFG_SDRAM_CFG;
+	im->ddr.sdram_cfg2 = CFG_SDRAM_CFG2;
+	im->ddr.sdram_mode = CFG_DDR_MODE;
+	im->ddr.sdram_mode_2 = CFG_DDR_MODE_2;
+
+	im->ddr.sdram_interval = CFG_DDR_INTERVAL;
+	udelay(200);
+
+	/* enable DDR controller */
+	im->ddr.sdram_cfg |= SDRAM_CFG_MEM_EN;
+#endif
+		
+	return msize;
+}
+#endif /*!CFG_SPD_EEPROM */
diff --git a/board/mpc8313erdb/u-boot-nand.lds b/board/mpc8313erdb/u-boot-nand.lds
new file mode 100644
index 0000000..f74d1c2
--- /dev/null
+++ b/board/mpc8313erdb/u-boot-nand.lds
@@ -0,0 +1,138 @@
+/*
+ * (C) Copyright 2006
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(powerpc)
+SEARCH_DIR(/lib); SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/local/lib); SEARCH_DIR(/usr/local/powerpc-any-elf/lib);
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  . = + SIZEOF_HEADERS;
+  .interp : { *(.interp) }
+  .hash          : { *(.hash)		}
+  .dynsym        : { *(.dynsym)		}
+  .dynstr        : { *(.dynstr)		}
+  .rel.text      : { *(.rel.text)		}
+  .rela.text     : { *(.rela.text) 	}
+  .rel.data      : { *(.rel.data)		}
+  .rela.data     : { *(.rela.data) 	}
+  .rel.rodata    : { *(.rel.rodata) 	}
+  .rela.rodata   : { *(.rela.rodata) 	}
+  .rel.got       : { *(.rel.got)		}
+  .rela.got      : { *(.rela.got)		}
+  .rel.ctors     : { *(.rel.ctors)	}
+  .rela.ctors    : { *(.rela.ctors)	}
+  .rel.dtors     : { *(.rel.dtors)	}
+  .rela.dtors    : { *(.rela.dtors)	}
+  .rel.bss       : { *(.rel.bss)		}
+  .rela.bss      : { *(.rela.bss)		}
+  .rel.plt       : { *(.rel.plt)		}
+  .rela.plt      : { *(.rela.plt)		}
+  .init          : { *(.init)	}
+  .plt : { *(.plt) }
+  .text      :
+  {
+    /* WARNING - the following is hand-optimized to fit within	*/
+    /* the sector layout of our flash chips!	XXX FIXME XXX	*/
+
+    cpu/mpc83xx/start.o	(.text)
+
+    /* Align to next NAND block */
+    . = ALIGN(0x4000);
+    common/environment.o  (.ppcenv)
+    /* Keep some space here for redundant env and potential bad env blocks */
+    . = ALIGN(0x10000);
+
+    *(.text)
+    *(.fixup)
+    *(.got1)
+  }
+  _etext = .;
+  PROVIDE (etext = .);
+  .rodata    :
+  {
+    *(.rodata)
+    *(.rodata1)
+    *(.rodata.str1.4)
+  }
+  .fini      : { *(.fini)    } =0
+  .ctors     : { *(.ctors)   }
+  .dtors     : { *(.dtors)   }
+
+  /* Read-write section, merged into data segment: */
+  . = (. + 0x00FF) & 0xFFFFFF00;
+  _erotext = .;
+  PROVIDE (erotext = .);
+  .reloc   :
+  {
+    *(.got)
+    _GOT2_TABLE_ = .;
+    *(.got2)
+    _FIXUP_TABLE_ = .;
+    *(.fixup)
+  }
+  __got2_entries = (_FIXUP_TABLE_ - _GOT2_TABLE_) >>2;
+  __fixup_entries = (. - _FIXUP_TABLE_)>>2;
+
+  .data    :
+  {
+    *(.data)
+    *(.data1)
+    *(.sdata)
+    *(.sdata2)
+    *(.dynamic)
+    CONSTRUCTORS
+  }
+  _edata  =  .;
+  PROVIDE (edata = .);
+
+  . = .;
+  __u_boot_cmd_start = .;
+  .u_boot_cmd : { *(.u_boot_cmd) }
+  __u_boot_cmd_end = .;
+
+
+  . = .;
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  . = ALIGN(256);
+  __init_begin = .;
+  .text.init : { *(.text.init) }
+  .data.init : { *(.data.init) }
+  . = ALIGN(256);
+  __init_end = .;
+
+  __bss_start = .;
+  .bss       :
+  {
+   *(.sbss) *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+  }
+
+  _end = . ;
+  PROVIDE (end = .);
+}
+ENTRY(_start)
diff --git a/cpu/mpc83xx/start.S b/cpu/mpc83xx/start.S
index 0f27bb6..bc7ae55 100644
--- a/cpu/mpc83xx/start.S
+++ b/cpu/mpc83xx/start.S
@@ -2,7 +2,7 @@
  * Copyright (C) 1998  Dan Malek <dmalek@jlc.net>
  * Copyright (C) 1999  Magnus Damm <kieraypc01.p.y.kie.era.ericsson.se>
  * Copyright (C) 2000, 2001,2002 Wolfgang Denk <wd@denx.de>
- * Copyright Freescale Semiconductor, Inc. 2004, 2006. All rights reserved.
+ * Copyright Freescale Semiconductor, Inc. 2004, 2006,2007. All rights reserved.
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -63,6 +63,9 @@
  * Use r14 to access the GOT
  */
 	START_GOT
+#if defined(CONFIG_NAND_SPL)
+	GOT_ENTRY(_GOT_TABLE_)
+#else
 	GOT_ENTRY(_GOT2_TABLE_)
 	GOT_ENTRY(_FIXUP_TABLE_)
 
@@ -74,6 +77,7 @@
 	GOT_ENTRY(__init_end)
 	GOT_ENTRY(_end)
 	GOT_ENTRY(__bss_start)
+#endif /* CONFIG_NAND_SPL */
 	END_GOT
 
 /*
@@ -100,6 +104,73 @@ version_string:
 	_HRCW_TABLE_ENTRY(CFG_HRCW_LOW)
 	_HRCW_TABLE_ENTRY(CFG_HRCW_HIGH)
 
+	.globl enable_addr_trans
+enable_addr_trans:
+	/* enable address translation */
+	mfmsr	r5
+	ori	r5, r5, (MSR_IR | MSR_DR)
+	mtmsr	r5
+	isync
+	blr
+
+/* Cache functions.
+ *
+ * Note: requires that all cache bits in
+ * HID0 are in the low half word.
+ */
+	.globl	icache_enable
+icache_enable:
+	mfspr	r3, HID0
+	ori	r3, r3, HID0_ICE
+	li	r4, HID0_ILOCK
+	andc	r3, r3, r4
+	ori	r4, r3, HID0_ICFI
+	isync
+	mtspr	HID0, r4    /* sets enable and invalidate, clears lock */
+	isync
+	mtspr	HID0, r3	/* clears invalidate */
+	blr
+
+	.globl	dcache_enable
+dcache_enable:
+	mfspr	r3, HID0
+	li	r5, HID0_DCFI|HID0_DLOCK
+	andc	r3, r3, r5
+	mtspr	HID0, r3		/* no invalidate, unlock */
+	ori	r3, r3, HID0_DCE
+	ori	r5, r3, HID0_DCFI
+	mtspr	HID0, r5		/* enable + invalidate */
+	mtspr	HID0, r3		/* enable */
+	sync
+	blr
+
+	.globl get_pvr
+get_pvr:
+	mfspr	r3, PVR
+	blr
+
+#ifdef CFG_INIT_RAM_LOCK
+lock_ram_in_cache:
+	/* Allocate Initial RAM in data cache.
+	 */
+	lis	r3, (CFG_INIT_RAM_ADDR & ~31)@h
+	ori	r3, r3, (CFG_INIT_RAM_ADDR & ~31)@l
+	li	r2, ((CFG_INIT_RAM_END & ~31) + \
+		     (CFG_INIT_RAM_ADDR & 31) + 31) / 32
+	mtctr	r2
+1:
+	dcbz	r0, r3
+	addi	r3, r3, 32
+	bdnz	1b
+
+	/* Lock the data cache */
+	mfspr	r0, HID0
+	ori	r0, r0, 0x1000
+	sync
+	mtspr	HID0, r0
+	sync
+	blr
+#endif /* CFG_INIT_RAM_LOCK */
 
 #ifndef CONFIG_DEFAULT_IMMR
 #error CONFIG_DEFAULT_IMMR must be defined
@@ -135,7 +206,7 @@ version_string:
 
 	.globl	_start
 _start: /* time t 0 */
-	li	r21, BOOTFLAG_COLD  /* Normal Power-On: Boot from FLASH*/
+	li	r19, BOOTFLAG_COLD  /* Normal Power-On: Boot from FLASH*/
 	nop
 	b	boot_cold
 
@@ -143,7 +214,7 @@ _start: /* time t 0 */
 
 	.globl	_start_warm
 _start_warm:
-	li	r21, BOOTFLAG_WARM	/* Software reboot	*/
+	li	r19, BOOTFLAG_WARM	/* Software reboot	*/
 	b	boot_warm
 
 
@@ -161,7 +232,7 @@ boot_warm: /* time t 5 */
 
 	bl	init_e300_core
 
-#ifndef CFG_RAMBOOT
+#if !defined(CFG_RAMBOOT) && !defined(CONFIG_NAND_U_BOOT)
 
 	/* Inflate flash location so it appears everywhere, calculate */
 	/* the absolute address in final location of the FLASH, jump  */
@@ -177,7 +248,7 @@ in_flash:
 #if 1 /* Remapping flash with LAW0. */
 	bl remap_flash_by_law0
 #endif
-#endif	/* CFG_RAMBOOT */
+#endif	/* !defined(CFG_RAMBOOT) && !defined(CONFIG_NAND_U_BOOT) */
 
 	/* setup the bats */
 	bl	setup_bats
@@ -230,8 +301,9 @@ in_flash:
 	/* run low-level CPU init code (in Flash)*/
 	bl	cpu_init_f
 
+#if !defined(CONFIG_NAND_SPL)
 	/* r3: BOOTFLAG */
-	mr	r3, r21
+	mr	r3, r19
 	/* run 1st part of board init code (in Flash)*/
 	bl	board_init_f
 
@@ -424,6 +496,7 @@ int_return:
 	lwz	r1,GPR1(r1)
 	SYNC
 	rfi
+#endif /* CONFIG_NAND_SPL */
 
 /*
  * This code initialises the E300 processor core
@@ -546,6 +619,7 @@ init_e300_core: /* time t 10 */
 	/*------------------------------*/
 	blr
 
+#if !defined(CONFIG_NAND_SPL)
 	.globl	invalidate_bats
 invalidate_bats:
 	/* invalidate BATs */
@@ -573,6 +647,7 @@ invalidate_bats:
 	isync
 	sync
 	blr
+#endif /* CONFIG_NAND_SPL */
 
 	/* setup_bats - set them up to some initial state */
 	.globl	setup_bats
@@ -580,148 +655,228 @@ setup_bats:
 	addis	r0, r0, 0x0000
 
 	/* IBAT 0 */
+#if ((CFG_IBAT0L == 0) && (CFG_IBAT0U == 0))
+	mtspr	IBAT0L, r0
+	mtspr	IBAT0U, r0
+#else
 	addis	r4, r0, CFG_IBAT0L@h
 	ori	r4, r4, CFG_IBAT0L@l
 	addis	r3, r0, CFG_IBAT0U@h
 	ori	r3, r3, CFG_IBAT0U@l
 	mtspr	IBAT0L, r4
 	mtspr	IBAT0U, r3
+#endif
 	isync
 
 	/* DBAT 0 */
+#if ((CFG_DBAT0L == 0) && (CFG_DBAT0U == 0))
+	mtspr	DBAT0L, r0
+	mtspr	DBAT0U, r0
+#else
 	addis	r4, r0, CFG_DBAT0L@h
 	ori	r4, r4, CFG_DBAT0L@l
 	addis	r3, r0, CFG_DBAT0U@h
 	ori	r3, r3, CFG_DBAT0U@l
 	mtspr	DBAT0L, r4
 	mtspr	DBAT0U, r3
+#endif
 	isync
 
 	/* IBAT 1 */
+#if ((CFG_IBAT1L == 0) && (CFG_IBAT1U == 0))
+	mtspr	IBAT1L, r0
+	mtspr	IBAT1U, r0
+#else
 	addis	r4, r0, CFG_IBAT1L@h
 	ori	r4, r4, CFG_IBAT1L@l
 	addis	r3, r0, CFG_IBAT1U@h
 	ori	r3, r3, CFG_IBAT1U@l
 	mtspr	IBAT1L, r4
 	mtspr	IBAT1U, r3
+#endif
 	isync
 
 	/* DBAT 1 */
+#if ((CFG_DBAT1L == 0) && (CFG_DBAT1U == 0))
+	mtspr	DBAT1L, r0
+	mtspr	DBAT1U, r0
+#else
 	addis	r4, r0, CFG_DBAT1L@h
 	ori	r4, r4, CFG_DBAT1L@l
 	addis	r3, r0, CFG_DBAT1U@h
 	ori	r3, r3, CFG_DBAT1U@l
 	mtspr	DBAT1L, r4
 	mtspr	DBAT1U, r3
+#endif
 	isync
 
 	/* IBAT 2 */
+#if ((CFG_IBAT2L == 0) && (CFG_IBAT2U == 0))
+	mtspr	IBAT2L, r0
+	mtspr	IBAT2U, r0
+#else
 	addis	r4, r0, CFG_IBAT2L@h
 	ori	r4, r4, CFG_IBAT2L@l
 	addis	r3, r0, CFG_IBAT2U@h
 	ori	r3, r3, CFG_IBAT2U@l
 	mtspr	IBAT2L, r4
 	mtspr	IBAT2U, r3
+#endif
 	isync
 
 	/* DBAT 2 */
+#if ((CFG_DBAT2L == 0) && (CFG_DBAT2U == 0))
+	mtspr	DBAT2L, r0
+	mtspr	DBAT2U, r0
+#else
 	addis	r4, r0, CFG_DBAT2L@h
 	ori	r4, r4, CFG_DBAT2L@l
 	addis	r3, r0, CFG_DBAT2U@h
 	ori	r3, r3, CFG_DBAT2U@l
 	mtspr	DBAT2L, r4
 	mtspr	DBAT2U, r3
+#endif
 	isync
 
 	/* IBAT 3 */
+#if ((CFG_IBAT3L == 0) && (CFG_IBAT3U == 0))
+	mtspr	IBAT3L, r0
+	mtspr	IBAT3U, r0
+#else
 	addis	r4, r0, CFG_IBAT3L@h
 	ori	r4, r4, CFG_IBAT3L@l
 	addis	r3, r0, CFG_IBAT3U@h
 	ori	r3, r3, CFG_IBAT3U@l
 	mtspr	IBAT3L, r4
 	mtspr	IBAT3U, r3
+#endif
 	isync
 
 	/* DBAT 3 */
+#if ((CFG_DBAT3L == 0) && (CFG_DBAT3U == 0))
+	mtspr	DBAT3L, r0
+	mtspr	DBAT3U, r0
+#else
 	addis	r4, r0, CFG_DBAT3L@h
 	ori	r4, r4, CFG_DBAT3L@l
 	addis	r3, r0, CFG_DBAT3U@h
 	ori	r3, r3, CFG_DBAT3U@l
 	mtspr	DBAT3L, r4
 	mtspr	DBAT3U, r3
+#endif
 	isync
 
 #if (CFG_HID2 & HID2_HBE)
 	/* IBAT 4 */
+#if ((CFG_IBAT4L == 0) && (CFG_IBAT4U == 0))
+	mtspr	IBAT4L, r0
+	mtspr	IBAT4U, r0
+#else
 	addis   r4, r0, CFG_IBAT4L@h
 	ori     r4, r4, CFG_IBAT4L@l
 	addis   r3, r0, CFG_IBAT4U@h
 	ori     r3, r3, CFG_IBAT4U@l
 	mtspr   IBAT4L, r4
 	mtspr   IBAT4U, r3
+#endif
 	isync
 
 	/* DBAT 4 */
+#if ((CFG_DBAT4L == 0) && (CFG_DBAT4U == 0))
+	mtspr	DBAT4L, r0
+	mtspr	DBAT4U, r0
+#else
 	addis   r4, r0, CFG_DBAT4L@h
 	ori     r4, r4, CFG_DBAT4L@l
 	addis   r3, r0, CFG_DBAT4U@h
 	ori     r3, r3, CFG_DBAT4U@l
 	mtspr   DBAT4L, r4
 	mtspr   DBAT4U, r3
+#endif
 	isync
 
 	/* IBAT 5 */
+#if ((CFG_IBAT5L == 0) && (CFG_IBAT5U == 0))
+	mtspr	IBAT5L, r0
+	mtspr	IBAT5U, r0
+#else
 	addis   r4, r0, CFG_IBAT5L@h
 	ori     r4, r4, CFG_IBAT5L@l
 	addis   r3, r0, CFG_IBAT5U@h
 	ori     r3, r3, CFG_IBAT5U@l
 	mtspr   IBAT5L, r4
 	mtspr   IBAT5U, r3
+#endif
 	isync
 
 	/* DBAT 5 */
+#if ((CFG_DBAT5L == 0) && (CFG_DBAT5U == 0))
+	mtspr	DBAT5L, r0
+	mtspr	DBAT5U, r0
+#else
 	addis   r4, r0, CFG_DBAT5L@h
 	ori     r4, r4, CFG_DBAT5L@l
 	addis   r3, r0, CFG_DBAT5U@h
 	ori     r3, r3, CFG_DBAT5U@l
 	mtspr   DBAT5L, r4
 	mtspr   DBAT5U, r3
+#endif
 	isync
 
 	/* IBAT 6 */
+#if ((CFG_IBAT6L == 0) && (CFG_IBAT6U == 0))
+	mtspr	IBAT6L, r0
+	mtspr	IBAT6U, r0
+#else
 	addis   r4, r0, CFG_IBAT6L@h
 	ori     r4, r4, CFG_IBAT6L@l
 	addis   r3, r0, CFG_IBAT6U@h
 	ori     r3, r3, CFG_IBAT6U@l
 	mtspr   IBAT6L, r4
 	mtspr   IBAT6U, r3
+#endif
 	isync
 
 	/* DBAT 6 */
+#if ((CFG_DBAT6L == 0) && (CFG_DBAT6U == 0))
+	mtspr	DBAT6L, r0
+	mtspr	DBAT6U, r0
+#else
 	addis   r4, r0, CFG_DBAT6L@h
 	ori     r4, r4, CFG_DBAT6L@l
 	addis   r3, r0, CFG_DBAT6U@h
 	ori     r3, r3, CFG_DBAT6U@l
 	mtspr   DBAT6L, r4
 	mtspr   DBAT6U, r3
+#endif
 	isync
 
 	/* IBAT 7 */
+#if ((CFG_IBAT7L == 0) && (CFG_IBAT7U == 0))
+	mtspr	IBAT7L, r0
+	mtspr	IBAT7U, r0
+#else
 	addis   r4, r0, CFG_IBAT7L@h
 	ori     r4, r4, CFG_IBAT7L@l
 	addis   r3, r0, CFG_IBAT7U@h
 	ori     r3, r3, CFG_IBAT7U@l
 	mtspr   IBAT7L, r4
 	mtspr   IBAT7U, r3
+#endif
 	isync
 
 	/* DBAT 7 */
+#if ((CFG_DBAT7L == 0) && (CFG_DBAT7U == 0))
+	mtspr	DBAT7L, r0
+	mtspr	DBAT7U, r0
+#else
 	addis   r4, r0, CFG_DBAT7L@h
 	ori     r4, r4, CFG_DBAT7L@l
 	addis   r3, r0, CFG_DBAT7U@h
 	ori     r3, r3, CFG_DBAT7U@l
 	mtspr   DBAT7L, r4
 	mtspr   DBAT7U, r3
+#endif
 	isync
 #endif
 
@@ -740,15 +895,7 @@ setup_bats:
 
 	blr
 
-	.globl enable_addr_trans
-enable_addr_trans:
-	/* enable address translation */
-	mfmsr	r5
-	ori	r5, r5, (MSR_IR | MSR_DR)
-	mtmsr	r5
-	isync
-	blr
-
+#if !defined(CONFIG_NAND_SPL)
 	.globl disable_addr_trans
 disable_addr_trans:
 	/* disable address translation */
@@ -766,19 +913,6 @@ disable_addr_trans:
  * Note: requires that all cache bits in
  * HID0 are in the low half word.
  */
-	.globl	icache_enable
-icache_enable:
-	mfspr	r3, HID0
-	ori	r3, r3, HID0_ICE
-	lis	r4, 0
-	ori	r4, r4, HID0_ILOCK
-	andc	r3, r3, r4
-	ori	r4, r3, HID0_ICFI
-	isync
-	mtspr	HID0, r4    /* sets enable and invalidate, clears lock */
-	isync
-	mtspr	HID0, r3	/* clears invalidate */
-	blr
 
 	.globl	icache_disable
 icache_disable:
@@ -799,19 +933,6 @@ icache_status:
 	rlwinm	r3, r3, (31 - HID0_ICE_SHIFT + 1), 31, 31
 	blr
 
-	.globl	dcache_enable
-dcache_enable:
-	mfspr	r3, HID0
-	li	r5, HID0_DCFI|HID0_DLOCK
-	andc	r3, r3, r5
-	mtspr	HID0, r3		/* no invalidate, unlock */
-	ori	r3, r3, HID0_DCE
-	ori	r5, r3, HID0_DCFI
-	mtspr	HID0, r5		/* enable + invalidate */
-	mtspr	HID0, r3		/* enable */
-	sync
-	blr
-
 	.globl	dcache_disable
 dcache_disable:
 	mfspr	r3, HID0
@@ -831,11 +952,6 @@ dcache_status:
 	rlwinm	r3, r3, (31 - HID0_DCE_SHIFT + 1), 31, 31
 	blr
 
-	.globl get_pvr
-get_pvr:
-	mfspr	r3, PVR
-	blr
-
 /*------------------------------------------------------------------------------- */
 /* Function:	 ppcDcbf */
 /* Description:	 Data Cache block flush */
@@ -883,6 +999,7 @@ ppcDWload:
 	blr
 
 /*-------------------------------------------------------------------*/
+#endif /* CONFIG_NAND_SPL */
 
 /*
  * void relocate_code (addr_sp, gd, addr_moni)
@@ -902,10 +1019,17 @@ relocate_code:
 	mr	r10, r5		/* Save copy of Destination Address */
 
 	mr	r3,  r5				/* Destination Address */
+
+#if !defined(CONFIG_NAND_SPL)
 	lis	r4, CFG_MONITOR_BASE@h		/* Source      Address */
 	ori	r4, r4, CFG_MONITOR_BASE@l
 	lwz	r5, GOT(__init_end)
 	sub	r5, r5, r4
+#else
+	lis	r4, CFG_NAND_BASE@h		/* Source      Address */
+	ori	r4, r4, CFG_NAND_BASE@l
+	li	r5, 0x1000			/* 4 kbyte bootloader */
+#endif /* CONFIG_NAND_SPL */
 	li	r6, CFG_CACHELINE_SIZE		/* Cache Line Size */
 
 	/*
@@ -1000,6 +1124,23 @@ relocate_code:
 
 in_ram:
 
+#if defined(CONFIG_NAND_SPL)
+	/*
+	 * Adjust got table entries to fix pointers to strings
+	 */
+	li	r0,__got_entries@sectoff@l
+	la	r4,GOT(_GOT_TABLE_)
+	cmpwi	r0,0
+	mtctr	r0
+	addi	r4,r4,-4
+	beq	4f
+3:	lwzu	r3,4(r4)
+	add	r3,r3,r15
+	stw	r3,0(r4)
+	bdnz	3b
+4:
+
+#else
 	/*
 	 * Relocation Function, r14 point to got2+0x8000
 	 *
@@ -1065,8 +1206,11 @@ clear_bss:
 
 	mr	r3, r9		/* Global Data pointer		*/
 	mr	r4, r10		/* Destination Address		*/
+#endif /* CONFIG_NAND_SPL */
+
 	bl	board_init_r
 
+#if !defined(CONFIG_NAND_SPL)
 	/*
 	 * Copy exception vector code to low memory
 	 *
@@ -1151,27 +1295,6 @@ trap_reloc:
 	blr
 
 #ifdef CFG_INIT_RAM_LOCK
-lock_ram_in_cache:
-	/* Allocate Initial RAM in data cache.
-	 */
-	lis	r3, (CFG_INIT_RAM_ADDR & ~31)@h
-	ori	r3, r3, (CFG_INIT_RAM_ADDR & ~31)@l
-	li	r2, ((CFG_INIT_RAM_END & ~31) + \
-		     (CFG_INIT_RAM_ADDR & 31) + 31) / 32
-	mtctr	r2
-1:
-	dcbz	r0, r3
-	addi	r3, r3, 32
-	bdnz	1b
-
-	/* Lock the data cache */
-	mfspr	r0, HID0
-	ori	r0, r0, 0x1000
-	sync
-	mtspr	HID0, r0
-	sync
-	blr
-
 .globl unlock_ram_in_cache
 unlock_ram_in_cache:
 	/* invalidate the INIT_RAM section */
@@ -1235,7 +1358,7 @@ map_flash_by_law1:
 	addi r4, r4, 1
 	bne 1b
 
-	stw r4, LBLAWAR1(r3) /* LBLAWAR1 <= 8MB Flash Size */
+	stw r4, LBLAWAR1(r3) /* LBLAWAR1 <= Flash Size */
 	blr
 
 	/* Though all the LBIU Local Access Windows and LBC Banks will be
@@ -1275,3 +1398,4 @@ remap_flash_by_law0:
 	stw r4, LBLAWBAR1(r3)
 	stw r4, LBLAWAR1(r3) /* Off LBIU LAW1 */
 	blr
+#endif /* CONFIG_NAND_SPL */
diff --git a/doc/README.mpc8313erdb b/doc/README.mpc8313erdb
index 31f0151..2c29478 100644
--- a/doc/README.mpc8313erdb
+++ b/doc/README.mpc8313erdb
@@ -7,12 +7,22 @@ Freescale MPC8313ERDB Board
 	
 	To boot using a 66 MHz crystal from the image at 0xFE000000 in NOR
 	flash, using the Hardware Reset Configuration set on the DIP switches:
+
+	REVA1 and REVA2 board
 	SW3		SW4
 	+------+	+------+
 	|      |	| **** |
 	| **** |	|      |
 	+------+ ON	+------+ ON
 	  4321		  4321
+
+	REVA board
+	SW3		SW4
+	+------+	+------+
+	|      |	| * ** |
+	| **** |	|  *   |
+	+------+ ON	+------+ ON
+	  4321		  4321
 	(where the '*' indicates the position of the tab of the switch.)
 
 2.	Memory Map
@@ -100,9 +110,100 @@ Freescale MPC8313ERDB Board
 	=>tftp 400000 ramdisk_img
 	=>tftp 700000 oft_dtb
 	=>bootm 200000 400000 700000
-	
 
-6	Notes
-	The U-Boot is not yet supported booting from NAND flash
-	The console baudrate for MPC8313ERDB is 115200bps.
+6. NAND Flash Boot
+
+6.1 
+    The MPC8313ERDB support the ability to boot from a small page
+    (512 byte) NAND flash, using the u-boot nand_spl tree to build the
+    u-boot-nand.bin file that contains both the stage 0 boot loader and
+    also the main u-boot image. The first 4k bytes of the first non-bad
+    page are used to hold the stage 0 boot loader, and are always read
+    using the hardware ECC functionality. The stage 0 boatloader writes
+    the BR0 chip select to the desired value, so can change the ECC
+    method to software by clearing the DECC bits of the BR0 register.
+    This is modified in the board configuration file by setting the DECC
+    field to 2 in the NAND Chip Select Base Register (CFG_NAND_BR_PRELIM)
+    for hardware ECC, or 0 for software ECC.
+
+    NOTE:  The binary image file must be written to the NAND Flash with
+    the same Hardware ECC method enabled so that the checksums are
+    compatible. If hardware ECC is used this is simply done by writing
+    the entire image using the hardware ECC.  If software ECC is desired
+    then the first 0x4000 bytes must be written with hardware ECC while
+    the rest of the image must be written with software ECC.
+
+6.2 
+    To boot using a 66 MHz crystal from an image in NAND Flash set the
+    DIP switches a follows:
+
+	REVA1 and REVA2 board
+	SW3		SW4
+	+------+	+------+
+	| *    |	|  *** |
+	|  *** |	| *    |
+	+------+ ON	+------+ ON
+	  4321		  4321
+	
+	(where the '*' indicates the position of the tab of the switch.)
+	
+6.3
+    To make NAND boot image, use MPC8313ERDB_NAND_config in section 4.
+
+    Make will create the u-boot-nand.bin file that contains both the
+    Stage 0 bootloader as well as u-boot.
+
+    If using hardware ECC, copy the new image file into the NAND flash:
+        tftp 100000 u-boot-nand.bin
+        nand erase 0 60000
+        nand write.jffs2 100000 0 50000
+
+    If using software ECC, copy the initial section using hardware ECC:
+        tftp 100000 u-boot-nand.bin
+        nand erase 0 60000
+        nand write.jffs2 100000 0 4000
+    and the rest using an version of u-boot with software ECC:
+        tftp 100000 u-boot-nand.bin
+        nand write.jffs2 104000 4000 50000
+
+    The environment variables are also kept in the NAND flash.
+
+    The stage 0 bootloader of up to 4 KBytes is loaded into the NAND FCM
+    buffer by the hardware boot sequencer. This code sets up the DDR and
+    then copies itself to DDR before loading the full u-boot image into
+    RAM.
+
+    During the boot sequence the stage 0 bootloader can display messages
+    to the console:
+
+        NAND SPL - U-Boot 1.1.6 (April 3 2007 - 10:00:00) MPC83XX
+        Loading from NAND : ........................
+
+    The second line shows the status of each block that is read from the
+    NAND flash. The staus may be any of the following:
+        .    = NAND Flash block read succesfully and copied to DDR
+        B    = NAND Flash block is marked as bad so was skipped
+        T    = Timeout occured waiting for NAND read to complete (fatal)
+        U    = Uncorrectable ECC error occured (fatal)
+        1-9,a-z = Number of 256 byte blocks with single correctable errors
+                  (only for software ECC when CFG_NAND_BOOT_SHOW_ECC_NUM
+                   is defined)
+
+    Configuration macros
+        CFG_NAND_BOOT_QUIET - suppress stage 0 messages, except fatal errors
+	CFG_NAND_BOOT_SHOW_ECC_NUM - report number of errors fixed by SW ECC
+        CFG_NAND_BLOCK_SIZE - number of data bytes in each NAND Flash block
+        CFG_NAND_PAGE_SIZE  - number of data bytes in each NAND Flash page
+        CFG_NAND_BAD_BLOCK_POS - byte position of the bad block marker
+        CFG_NAND_RELOC      - location to copy the stage 0 bootloader to
+        CFG_NAND_U_BOOT_DST - location to copy the main u-boot image to
+        CFG_NAND_U_BOOT_SIZE - size of the main u-boot image in bytes
+        CFG_NAND_U_BOOT_START - start address to jump to in main u-boot
+
+6.4
+    Booting from NAND device is not supported on MPC8313ERDB REVA board 
+    because of hardware issue.
+
+7 Notes
+    The console baudrate for MPC8313ERDB is 115200bps.
 	
diff --git a/include/configs/MPC8313ERDB.h b/include/configs/MPC8313ERDB.h
index addc682..20cca44 100644
--- a/include/configs/MPC8313ERDB.h
+++ b/include/configs/MPC8313ERDB.h
@@ -172,10 +172,10 @@
 #define CFG_FLASH_EMPTY_INFO			/* display empty sectors */
 #define CFG_FLASH_USE_BUFFER_WRITE		/* buffer up multiple bytes */
 
-#define CFG_BR0_PRELIM		(CFG_FLASH_BASE |    /* flash Base address */ \
+#define CFG_FLASH_BR_PRELIM	(CFG_FLASH_BASE |    /* flash Base address */ \
 				(2 << BR_PS_SHIFT) | /* 16 bit port size */ \
 				BR_V)		     /* valid */
-#define CFG_OR0_PRELIM		( 0xFF000000         /* 16 MByte */ \
+#define CFG_FLASH_OR_PRELIM	( 0xFF000000         /* 16 MByte */ \
 				| OR_GPCM_XACS \
 				| OR_GPCM_SCY_9 \
 				| OR_GPCM_EHTR \
@@ -193,7 +193,7 @@
 
 #define CFG_MONITOR_BASE	TEXT_BASE	/* start of monitor */
 
-#if (CFG_MONITOR_BASE < CFG_FLASH_BASE)
+#if (CFG_MONITOR_BASE < CFG_FLASH_BASE) && !defined(CONFIG_NAND_U_BOOT)
 #define CFG_RAMBOOT
 #else
 #undef  CFG_RAMBOOT
@@ -221,17 +221,21 @@
 #define CFG_LBC_MRTPR	0x20000000  /*TODO */  /* LB refresh timer prescal, 266MHz/32 */
 
 /* drivers/nand/nand.c */
+#ifdef CONFIG_NAND_SPL
+#define CFG_NAND_BASE		0xFFF00000
+#else
 #define CFG_NAND_BASE		0xE2800000 /* 0xF0000000 */
+#endif
 #define CFG_MAX_NAND_DEVICE	1
 #define NAND_MAX_CHIPS		1
 #define CONFIG_MTD_NAND_VERIFY_WRITE
 
-#define CFG_BR1_PRELIM		( CFG_NAND_BASE \
+#define CFG_NAND_BR_PRELIM	( CFG_NAND_BASE \
 				| (2<<BR_DECC_SHIFT) /* Use HW ECC */ \
 				| BR_PS_8            /* Port Size = 8 bit */ \
 				| BR_MS_FCM          /* MSEL = FCM */ \
 				| BR_V )             /* valid */
-#define CFG_OR1_PRELIM		( 0xFFFF8000	/* length 32K */ \
+#define CFG_NAND_OR_PRELIM	( 0xFFFF8000	/* length 32K */ \
 				| OR_FCM_CSCT \
 				| OR_FCM_CST \
 				| OR_FCM_CHT \
@@ -243,6 +247,52 @@
 #define CFG_LBLAWBAR1_PRELIM	CFG_NAND_BASE
 #define CFG_LBLAWAR1_PRELIM	0x8000000E	/* 32KB  */
 
+/*
+ * Swap CS0 / CS1 based upon NAND or NOR Flash Boot mode
+ */
+#if defined(CONFIG_NAND_U_BOOT)
+#define CFG_BR0_PRELIM		CFG_NAND_BR_PRELIM  /* NAND Base Address */
+#define CFG_OR0_PRELIM		CFG_NAND_OR_PRELIM  /* NAND Options */
+#define CFG_BR1_PRELIM		CFG_FLASH_BR_PRELIM /* NOR Base address */
+#define CFG_OR1_PRELIM		CFG_FLASH_OR_PRELIM /* NOR Options */
+#else
+#define CFG_BR0_PRELIM		CFG_FLASH_BR_PRELIM /* NOR Base address */
+#define CFG_OR0_PRELIM		CFG_FLASH_OR_PRELIM /* NOR Options */
+#define CFG_BR1_PRELIM		CFG_NAND_BR_PRELIM  /* NAND Base Address */
+#define CFG_OR1_PRELIM		CFG_NAND_OR_PRELIM  /* NAND Options */
+#endif /* CONFIG_NAND_U_BOOT */
+
+/*
+ * NAND Boot Configuration, for board/../nand_boot.c
+ */
+#define CFG_NAND_BR0_PRELIM	CFG_NAND_BR_PRELIM
+#define CFG_NAND_OR0_PRELIM	CFG_NAND_OR_PRELIM
+#define CFG_NAND_LBLAWBAR0_PRELIM	CFG_NAND_BASE
+#define CFG_NAND_LBLAWAR0_PRELIM	0x8000000E /* 32KB  */
+
+#undef  CFG_NAND_BOOT_QUIET		/* Enable NAND boot status messages */
+#define CFG_NAND_BOOT_SHOW_ECC_NUM	/* Show corrected ECC errors */
+#define CFG_NAND_RELOC		(0x10000)	/* Stage 1 load address */
+#define CFG_NAND_PAGE_SIZE	(512)		/* NAND chip page size */
+#define CFG_NAND_BLOCK_SIZE	(16 << 10)	/* NAND chip block size */
+#define CFG_NAND_BAD_BLOCK_POS	(5)		/* Bad block marker location */
+#define CFG_NAND_FMR		((14 << FMR_CWTO_SHIFT) | \
+				(0 << FMR_AL_SHIFT))
+
+#define CFG_NAND_U_BOOT_SIZE	(384 << 10)	/* Size of RAM U-Boot image */
+#define CFG_NAND_U_BOOT_DST	(0x01000000)	/* Load NUB to this addr */
+#define CFG_NAND_U_BOOT_START	(CFG_NAND_U_BOOT_DST + 0x120) /* NUB start */
+/*
+ * JFFS2 configuration
+ */
+#define CONFIG_JFFS2_NAND
+
+/* mtdparts command line support */
+#define CONFIG_JFFS2_CMDLINE
+#define MTDIDS_DEFAULT		"nor0=nor,nand0=nand"
+#define MTDPARTS_DEFAULT	"mtdparts=nand:-@4m(jffs2)"
+#define NAND_CACHE_PAGES	32
+
 #define CFG_VSC7385_BASE	0xF0000000
 
 #define CONFIG_VSC7385_ENET			/* VSC7385 ethernet support */
@@ -380,7 +430,11 @@
 /*
  * Environment
  */
-#ifndef CFG_RAMBOOT
+#if defined(CONFIG_NAND_U_BOOT)
+	#define CFG_ENV_IS_IN_NAND	1
+	#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+	#define CFG_ENV_OFFSET		((512<<10) - (CFG_NAND_BLOCK_SIZE<<1))
+#elif !defined(CFG_RAMBOOT)
 	#define CFG_ENV_IS_IN_FLASH	1
 	#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + 0x50000)
 	#define CFG_ENV_SECT_SIZE	0x10000	/* 128K(one sector) for env */
@@ -403,6 +457,7 @@
 				| CFG_CMD_MII		\
 				| CFG_CMD_DATE		\
 				| CFG_CMD_PCI		\
+				| CFG_CMD_JFFS2		\
 				| CFG_CMD_NAND)
 
 #define CFG_RAMBOOT_COMMANDS	( CFG_BASE_COMMANDS &	\
@@ -490,7 +545,21 @@
 #endif
 #endif /* PCI_66M */
 
-/* HRCWH: 0xa0606C00 */
+#ifdef CONFIG_NAND_SPL
+#define CFG_HRCW_HIGH (\
+	HRCWH_PCI_HOST |\
+	HRCWH_PCI1_ARBITER_ENABLE |\
+	HRCWH_CORE_ENABLE |\
+	HRCWH_FROM_0XFFF00100 |\
+	HRCWH_BOOTSEQ_DISABLE |\
+	HRCWH_SW_WATCHDOG_DISABLE |\
+	HRCWH_ROM_LOC_NAND_SP_8BIT |\
+	HRCWH_RL_EXT_NAND |\
+	HRCWH_TSEC1M_IN_RGMII |\
+	HRCWH_TSEC2M_IN_RGMII |\
+	HRCWH_BIG_ENDIAN |\
+	HRCWH_LALE_NORMAL)
+#else /* HRCWH: 0xa0606C00 */
 #define CFG_HRCW_HIGH (\
 	HRCWH_PCI_HOST |\
 	HRCWH_PCI1_ARBITER_ENABLE |\
@@ -504,6 +573,7 @@
 	HRCWH_TSEC2M_IN_RGMII |\
 	HRCWH_BIG_ENDIAN |\
 	HRCWH_LALE_NORMAL)
+#endif
 /* System IO Config */
 #define CFG_SICRH	(SICRH_TSOBI1 | SICRH_TSOBI2) /* RGMII */
 #define CFG_SICRL	SICRL_USBDR /* Enable Internal USB Phy  */
diff --git a/nand_spl/board/mpc8313erdb/Makefile b/nand_spl/board/mpc8313erdb/Makefile
new file mode 100644
index 0000000..415ce9f
--- /dev/null
+++ b/nand_spl/board/mpc8313erdb/Makefile
@@ -0,0 +1,90 @@
+#
+# (C) Copyright 2007, Freescale Semiconductor Inc.
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE) $(PLATFORM_LDFLAGS)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o
+COBJS	= sdram.o nand_boot.o nand_ecc.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/$(BOARDDIR)
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-16k.bin
+
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-16k.bin: $(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} --pad-to=$(PAD_TO) -O binary $< $@
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $(obj)start.S
+	ln -s $(SRCTREE)/cpu/mpc83xx/start.S $(obj)start.S
+
+# from board directory
+$(obj)sdram.c:
+	@rm -f $(obj)sdram.c
+	ln -s $(SRCTREE)/board/mpc8313erdb/sdram.c $(obj)sdram.c
+
+$(obj)nand_boot.c:
+	@rm -f $(obj)nand_boot.c
+	ln -s $(SRCTREE)/board/mpc8313erdb/nand_boot.c $(obj)nand_boot.c
+
+$(obj)nand_ecc.c:
+	@rm -f $(obj)nand_ecc.c
+	ln -s $(SRCTREE)/board/mpc8313erdb/nand_ecc.c $(obj)nand_ecc.c
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/nand_spl/board/mpc8313erdb/config.mk b/nand_spl/board/mpc8313erdb/config.mk
new file mode 100644
index 0000000..0ebc649
--- /dev/null
+++ b/nand_spl/board/mpc8313erdb/config.mk
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2007, Freescale Semiconductor Inc.
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Freescale MPC8313ERDB Reference Platform board
+#
+#
+# TEXT_BASE for SPL:
+#
+# On Boot-from-NAND the FCM buffer is mapped to the boot space. This
+# will be either 0x00000000 for low boot or 0xFFF00000 for high boot.
+# The u-boot NAND bootload is configured to use high boot only so
+# that it does not conflict with the DDR memory which is configured
+# at 0x00000000. Accordingly TEXT_BASE is set to the high boot memory
+# space at 0xFFF00000.
+#
+TEXT_BASE = 0xFFF00000
+
+# PAD_TO used to generate a 16kByte binary needed for the combined image
+# -> PAD_TO = TEXT_BASE + 0x4000
+PAD_TO	= 0xFFF04000
+
+ifeq ($(debug),1)
+PLATFORM_CPPFLAGS += -DDEBUG
+endif
+
diff --git a/nand_spl/board/mpc8313erdb/u-boot.lds b/nand_spl/board/mpc8313erdb/u-boot.lds
new file mode 100644
index 0000000..7754967
--- /dev/null
+++ b/nand_spl/board/mpc8313erdb/u-boot.lds
@@ -0,0 +1,64 @@
+/*
+ * (C) Copyright 2007, Freescale Semiconductor Inc.
+ *
+ * (C) Copyright 2006
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(powerpc:common)
+SECTIONS
+{
+  .text      :
+  {
+    start.o	(.text)
+
+    *(.text)
+    *(.fixup)
+  }
+  _etext = .;
+
+  .reloc    :
+  {
+    _GOT_TABLE_ = .;
+    *(.got*)
+    __got_end = .;
+    *(.got2)
+  }
+  __got_entries = (__got_end - _GOT_TABLE_) >> 2;
+
+  .data    :
+  {
+    *(.rodata*)
+    *(.data*)
+    *(.sdata*)
+  }
+
+  _edata  =  .;
+
+  __bss_start = .;
+  .bss       :
+  {
+   *(.sbss)
+   *(.bss)
+  }
+
+  _end = . ;
+}
-- 
1.5.0

