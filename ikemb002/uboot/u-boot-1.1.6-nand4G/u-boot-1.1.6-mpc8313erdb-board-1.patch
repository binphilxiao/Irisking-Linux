diff -purN /dev/null u-boot.open/board/mpc8313erdb/mpc8313erdb.c
--- /dev/null	2006-12-22 02:40:20.383302336 +0800
+++ u-boot.open/board/mpc8313erdb/mpc8313erdb.c	2006-12-26 15:12:28.000000000 +0800
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) Freescale Semiconductor, Inc. 2006. 
+ * 
+ * Initialized by Nick.Spence@freescale.com
+ *                Wilson.Lo@freescale.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ */
+
+#include <common.h>
+#include <ioports.h>
+#include <mpc83xx.h>
+#include <asm/mmu.h>
+#include <asm/mpc8349_pci.h>
+#include <spd.h>
+#include <miiphy.h>
+#include <command.h>
+#include <ft_build.h>
+#if defined(CONFIG_SPD_EEPROM)
+#include <spd_sdram.h>
+#endif
+int fixed_sdram(void);
+void sdram_init(void);
+
+int board_early_init_f(void)
+{
+	return 0;
+}
+
+#define ns2clk(ns) (ns / (1000000000 / CONFIG_83XX_CLKIN) + 1)
+
+long int initdram(int board_type)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+
+	u32 msize = 0;
+
+	if ((im->sysconf.immrbar & IMMRBAR_BASE_ADDR) != (u32) im)
+		return -1;
+
+	puts("Initializing\n");
+
+	/* DDR SDRAM - Main SODIMM */
+	im->sysconf.ddrlaw[0].bar = CFG_DDR_BASE & LAWBAR_BAR;
+#if defined(CONFIG_SPD_EEPROM)
+	msize = spd_sdram();
+#else
+	msize = fixed_sdram();
+#endif
+
+	/* Local Bus setup lbcr and mrtpr */
+	lbc->lbcr = CFG_LBC_LBCR;
+	lbc->mrtpr = CFG_LBC_MRTPR;
+	asm("sync");
+
+	puts("   DDR RAM: ");
+	/* return total bus SDRAM size(bytes)  -- DDR */
+	return (msize * 1024 * 1024);
+}
+
+#if !defined(CONFIG_SPD_EEPROM)
+/*************************************************************************
+ *  fixed sdram init -- doesn't use serial presence detect.
+ ************************************************************************/
+int fixed_sdram(void)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	u32 msize = 0;
+	u32 ddr_size;
+	u32 ddr_size_log2;
+
+	msize = CFG_DDR_SIZE;
+	for (ddr_size = msize << 20, ddr_size_log2 = 0;
+	     (ddr_size > 1);
+	     ddr_size = ddr_size >> 1, ddr_size_log2++) {
+		if (ddr_size & 1) {
+			return -1;
+		}
+	}
+	im->sysconf.ddrlaw[0].bar = ((CFG_DDR_SDRAM_BASE >> 12) & 0xfffff);
+	im->sysconf.ddrlaw[0].ar = LAWAR_EN | ((ddr_size_log2 - 1) & LAWAR_SIZE);
+	im->sysconf.ddrcdr = CFG_DDRCDR;
+
+#if (CFG_DDR_SIZE != 128)
+#warning Currenly any ddr size other than 128 is not supported
+#endif
+	im->ddr.csbnds[0].csbnds = 0x00000007;
+	im->ddr.cs_config[0] = CFG_DDR_CONFIG;
+
+	/* currently we use only one CS, so disable the other banks */
+	im->ddr.cs_config[1] = 0;
+	im->ddr.cs_config[2] = 0;
+	im->ddr.cs_config[3] = 0;
+
+	im->ddr.sdram_clk_cntl = CFG_DDR_CLK_CNTL;
+	im->ddr.timing_cfg_3 = CFG_DDR_TIMING_3;
+	im->ddr.timing_cfg_1 = CFG_DDR_TIMING_1;
+	im->ddr.timing_cfg_2 = CFG_DDR_TIMING_2;
+	im->ddr.timing_cfg_0 = CFG_DDR_TIMING_0;
+	im->ddr.sdram_cfg = CFG_SDRAM_CFG;
+	im->ddr.sdram_cfg2 = CFG_SDRAM_CFG2;
+	im->ddr.sdram_mode = CFG_DDR_MODE;
+	im->ddr.sdram_mode_2 = CFG_DDR_MODE_2;
+
+	im->ddr.sdram_interval = CFG_DDR_INTERVAL;
+	udelay(200);
+
+	/* enable DDR controller */
+	im->ddr.sdram_cfg |= SDRAM_CFG_MEM_EN;
+	return msize;
+}
+#endif /*!CFG_SPD_EEPROM */
+
+int checkboard(void)
+{
+	uint*	led_ptr;
+	puts("Board: Freescale MPC8313ERDB\n");
+	
+	led_ptr = (uint*) (0xFA000000);
+	*led_ptr = 0x00000000;
+
+	return 0;
+}
+
+
+#if defined(CONFIG_OF_FLAT_TREE) && defined(CONFIG_OF_BOARD_SETUP)
+
+extern void ft_cpu_setup(void *blob, bd_t *bd);
+extern void ft_pci_setup(void *blob, bd_t *bd);
+
+void
+ft_board_setup(void *blob, bd_t *bd)
+{
+	u32 *p;
+	int len;
+
+#ifdef CONFIG_PCI
+	ft_pci_setup(blob, bd);
+#endif
+	ft_cpu_setup(blob, bd);
+
+	p = ft_get_prop(blob, "/memory/reg", &len);
+	if (p != NULL) {
+		*p++ = cpu_to_be32(bd->bi_memstart);
+		*p = cpu_to_be32(bd->bi_memsize);
+	}
+}
+#endif
diff -purN /dev/null u-boot.open/board/mpc8313erdb/Makefile
--- /dev/null	2006-12-22 02:40:20.383302336 +0800
+++ u-boot.open/board/mpc8313erdb/Makefile	2006-12-26 15:12:28.000000000 +0800
@@ -0,0 +1,50 @@
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= $(BOARD).o pci.o nand.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -purN /dev/null u-boot.open/board/mpc8313erdb/u-boot.lds
--- /dev/null	2006-12-22 02:40:20.383302336 +0800
+++ u-boot.open/board/mpc8313erdb/u-boot.lds	2006-12-26 15:12:28.000000000 +0800
@@ -0,0 +1,123 @@
+/*
+ * (C) Copyright 2006
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(powerpc)
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  . = + SIZEOF_HEADERS;
+  .interp : { *(.interp) }
+  .hash          : { *(.hash)		}
+  .dynsym        : { *(.dynsym)		}
+  .dynstr        : { *(.dynstr)		}
+  .rel.text      : { *(.rel.text)		}
+  .rela.text     : { *(.rela.text) 	}
+  .rel.data      : { *(.rel.data)		}
+  .rela.data     : { *(.rela.data) 	}
+  .rel.rodata    : { *(.rel.rodata) 	}
+  .rela.rodata   : { *(.rela.rodata) 	}
+  .rel.got       : { *(.rel.got)		}
+  .rela.got      : { *(.rela.got)		}
+  .rel.ctors     : { *(.rel.ctors)	}
+  .rela.ctors    : { *(.rela.ctors)	}
+  .rel.dtors     : { *(.rel.dtors)	}
+  .rela.dtors    : { *(.rela.dtors)	}
+  .rel.bss       : { *(.rel.bss)		}
+  .rela.bss      : { *(.rela.bss)		}
+  .rel.plt       : { *(.rel.plt)		}
+  .rela.plt      : { *(.rela.plt)		}
+  .init          : { *(.init)	}
+  .plt : { *(.plt) }
+  .text      :
+  {
+    cpu/mpc83xx/start.o	(.text)
+    *(.text)
+    *(.fixup)
+    *(.got1)
+    . = ALIGN(16);
+    *(.rodata)
+    *(.rodata1)
+    *(.rodata.str1.4)
+    *(.eh_frame)
+  }
+  .fini      : { *(.fini)    } =0
+  .ctors     : { *(.ctors)   }
+  .dtors     : { *(.dtors)   }
+
+  /* Read-write section, merged into data segment: */
+  . = (. + 0x0FFF) & 0xFFFFF000;
+  _erotext = .;
+  PROVIDE (erotext = .);
+  .reloc   :
+  {
+    *(.got)
+    _GOT2_TABLE_ = .;
+    *(.got2)
+    _FIXUP_TABLE_ = .;
+    *(.fixup)
+  }
+  __got2_entries = (_FIXUP_TABLE_ - _GOT2_TABLE_) >> 2;
+  __fixup_entries = (. - _FIXUP_TABLE_) >> 2;
+
+  .data    :
+  {
+    *(.data)
+    *(.data1)
+    *(.sdata)
+    *(.sdata2)
+    *(.dynamic)
+    CONSTRUCTORS
+  }
+  _edata  =  .;
+  PROVIDE (edata = .);
+
+  . = .;
+  __u_boot_cmd_start = .;
+  .u_boot_cmd : { *(.u_boot_cmd) }
+  __u_boot_cmd_end = .;
+
+
+  . = .;
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  . = ALIGN(4096);
+  __init_begin = .;
+  .text.init : { *(.text.init) }
+  .data.init : { *(.data.init) }
+  . = ALIGN(4096);
+  __init_end = .;
+
+  __bss_start = .;
+  .bss       :
+  {
+   *(.sbss) *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+  }
+  _end = . ;
+  PROVIDE (end = .);
+}
+ENTRY(_start)
diff -purN /dev/null u-boot.open/board/mpc8313erdb/pci.c
--- /dev/null	2006-12-22 02:40:20.383302336 +0800
+++ u-boot.open/board/mpc8313erdb/pci.c	2006-12-26 15:12:28.000000000 +0800
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) Freescale Semiconductor, Inc. 2006. 
+ * 
+ * Initialized by Nick.Spence@freescale.com
+ *                Wilson.Lo@freescale.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <asm/mmu.h>
+#include <common.h>
+#include <asm/global_data.h>
+#include <pci.h>
+#include <asm/mpc8349_pci.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_PCI
+
+/* System RAM mapped to PCI space */
+#define CONFIG_PCI_SYS_MEM_BUS	CFG_SDRAM_BASE
+#define CONFIG_PCI_SYS_MEM_PHYS	CFG_SDRAM_BASE
+
+#ifndef CONFIG_PCI_PNP
+static struct pci_config_table pci_mpc8313emds_config_table[] = {
+	{PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+	 PCI_IDSEL_NUMBER, PCI_ANY_ID,
+	 pci_cfgfunc_config_device, {PCI_ENET0_IOADDR,
+				     PCI_ENET0_MEMADDR,
+				     PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER}
+	 },
+	{}
+};
+#endif
+
+static struct pci_controller pci_hose[] = {
+	{
+#ifndef CONFIG_PCI_PNP
+	      config_table:pci_mpc8313emds_config_table,
+#endif
+	 }
+};
+
+/**************************************************************************
+ * pci_init_board()
+ *
+ * NOTICE: PCI2 is not currently supported
+ *
+ */
+void pci_init_board(void)
+{
+	volatile immap_t *immr;
+	volatile clk83xx_t *clk;
+	volatile law83xx_t *pci_law;
+	volatile pot83xx_t *pci_pot;
+	volatile pcictrl83xx_t *pci_ctrl;
+	volatile pciconf83xx_t *pci_conf;
+	u16 reg16;
+	u32 dev;
+	struct pci_controller *hose;
+
+	immr = (immap_t *) CFG_IMMR;
+	clk = (clk83xx_t *) & immr->clk;
+	pci_law = immr->sysconf.pcilaw;
+	pci_pot = immr->ios.pot;
+	pci_ctrl = immr->pci_ctrl;
+	pci_conf = immr->pci_conf;
+
+	hose = &pci_hose[0];
+
+	/*
+	 * Enable all 3 PCI_CLK_OUTPUTs
+	 */
+
+	udelay(2000);
+	clk->occr |= 0xe0000000;
+	udelay(2000);
+
+	/*
+	 * Release PCI RST Output signal
+	 */
+	pci_ctrl->gcr = 0;
+	udelay(2000);
+	pci_ctrl->gcr = 1;
+
+	/* We need to wait at least a 1sec based on PCI specs */
+	{
+		int i;
+
+		for (i = 0; i < 1000; ++i)
+			udelay(1000);
+	}
+
+	/*
+	 * Configure PCI Local Access Windows
+	 */
+	pci_law[0].bar = CFG_PCI1_MEM_PHYS & LAWBAR_BAR;
+	pci_law[0].ar = LAWAR_EN | LAWAR_SIZE_512M;
+
+	pci_law[1].bar = CFG_PCI1_IO_PHYS & LAWBAR_BAR;
+	pci_law[1].ar = LAWAR_EN | LAWAR_SIZE_1M;
+
+	/*
+	 * Configure PCI Outbound Translation Windows
+	 */
+
+	/* PCI1 mem space - prefetch */
+	pci_pot[0].potar = (CFG_PCI1_MEM_BASE >> 12) & POTAR_TA_MASK;
+	pci_pot[0].pobar = (CFG_PCI1_MEM_PHYS >> 12) & POBAR_BA_MASK;
+	pci_pot[0].pocmr = POCMR_EN | POCMR_PREFETCH_EN |
+			   (POCMR_CM_256M & POCMR_CM_MASK);
+
+	/* PCI1 IO space */
+	pci_pot[1].potar = (CFG_PCI1_IO_BASE >> 12) & POTAR_TA_MASK;
+	pci_pot[1].pobar = (CFG_PCI1_IO_PHYS >> 12) & POBAR_BA_MASK;
+	pci_pot[1].pocmr = POCMR_EN | POCMR_IO |
+			   (POCMR_CM_1M & POCMR_CM_MASK);
+
+	/* PCI1 mmio - non-prefetch mem space */
+	pci_pot[2].potar = (CFG_PCI1_MMIO_BASE >> 12) & POTAR_TA_MASK;
+	pci_pot[2].pobar = (CFG_PCI1_MMIO_PHYS >> 12) & POBAR_BA_MASK;
+	pci_pot[2].pocmr = POCMR_EN | (POCMR_CM_256M & POCMR_CM_MASK);
+
+	/*
+	 * Configure PCI Inbound Translation Windows
+	 */
+
+	/* we need RAM mapped to PCI space for the devices to
+	 * access main memory */
+	pci_ctrl->pitar1 = 0x0;
+	pci_ctrl->pibar1 = 0x0;
+	pci_ctrl->piebar1 = 0x0;
+	pci_ctrl->piwar1 = PIWAR_EN | PIWAR_PF | PIWAR_RTT_SNOOP |
+			   PIWAR_WTT_SNOOP | (__ilog2(gd->ram_size) - 1);
+
+	hose->first_busno = 0;
+	hose->last_busno = 0xff;
+
+	/* PCI memory prefetch space */
+	pci_set_region(hose->regions,
+		       CFG_PCI1_MEM_BASE,
+		       CFG_PCI1_MEM_PHYS,
+		       CFG_PCI1_MEM_SIZE,
+		       PCI_REGION_MEM | PCI_REGION_PREFETCH);
+
+	/* PCI memory space */
+	pci_set_region(hose->regions + 1,
+		       CFG_PCI1_MMIO_BASE,
+		       CFG_PCI1_MMIO_PHYS,
+		       CFG_PCI1_MMIO_SIZE,
+		       PCI_REGION_MEM);
+
+	/* PCI IO space */
+	pci_set_region(hose->regions + 2,
+		       CFG_PCI1_IO_BASE,
+		       CFG_PCI1_IO_PHYS,
+		       CFG_PCI1_IO_SIZE,
+		       PCI_REGION_IO);
+
+	/* System memory space */
+	pci_set_region(hose->regions + 3,
+		       CONFIG_PCI_SYS_MEM_BUS,
+		       CONFIG_PCI_SYS_MEM_PHYS,
+		       gd->ram_size,
+		       PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	hose->region_count = 4;
+
+	pci_setup_indirect(hose,
+			   (CFG_IMMR + 0x8300),
+			   (CFG_IMMR + 0x8304));
+
+	pci_register_hose(hose);
+
+	/*
+	 * Write to Command register
+	 */
+	reg16 = 0xff;
+	dev = PCI_BDF(hose->first_busno, 0, 0);
+	pci_hose_read_config_word(hose, dev, PCI_COMMAND, &reg16);
+	reg16 |= PCI_COMMAND_SERR | PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	pci_hose_write_config_word(hose, dev, PCI_COMMAND, reg16);
+
+	/*
+	 * Clear non-reserved bits in status register.
+	 */
+	pci_hose_write_config_word(hose, dev, PCI_STATUS, 0xffff);
+	pci_hose_write_config_byte(hose, dev, PCI_LATENCY_TIMER, 0x80);
+	pci_hose_write_config_byte(hose, dev, PCI_CACHE_LINE_SIZE, 0x08);
+
+#ifdef CONFIG_PCI_SCAN_SHOW
+	printf("PCI:   Bus Dev VenId DevId Class Int\n");
+#endif
+	/*
+	 * Hose scan.
+	 */
+	hose->last_busno = pci_hose_scan(hose);
+}
+
+#ifdef CONFIG_OF_FLAT_TREE
+void
+ft_pci_setup(void *blob, bd_t *bd)
+{
+        u32 *p;
+        int len;
+
+        p = (u32 *)ft_get_prop(blob, "/" OF_SOC "/pci@8500/bus-range", &len);
+        if (p != NULL) {
+                p[0] = pci_hose[0].first_busno;
+                p[1] = pci_hose[0].last_busno;
+        }
+
+}
+#endif /* CONFIG_OF_FLAT_TREE */
+#endif /* CONFIG_PCI */
diff -purN /dev/null u-boot.open/board/mpc8313erdb/nand.c
--- /dev/null	2006-12-22 02:40:20.383302336 +0800
+++ u-boot.open/board/mpc8313erdb/nand.c	2006-12-26 15:12:28.000000000 +0800
@@ -0,0 +1,867 @@
+/*
+ * Copyright (C) Freescale Semiconductor, Inc. 2006. 
+ * 
+ * Initialized by Nick.Spence@freescale.com
+ *                Wilson.Lo@freescale.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+#if defined(CFG_NAND_LEGACY)
+ #error "U-Boot legacy NAND commands not supported."
+#else
+
+#include <malloc.h>
+#include <asm/errno.h>
+#include <nand.h>
+
+#undef CFG_FCM_DEBUG
+#define CFG_FCM_DEBUG_LVL 1
+#ifdef CFG_FCM_DEBUG
+#define FCM_DEBUG(n, args...)				\
+	do {						\
+		if (n <= (CFG_FCM_DEBUG_LVL + 0))	\
+			printf(args);			\
+	} while(0)
+#else /* CONFIG_FCM_DEBUG */
+#define FCM_DEBUG(n, args...) do { } while(0)
+#endif
+
+#define MIN(x, y)		((x < y) ? x : y)
+
+#define ERR_BYTE 0xFF	/* Value returned for read bytes when read failed */
+
+#define FCM_TIMEOUT_USECS 100000 /* Maximum number of uSecs to wait for FCM */
+
+/* Private structure holding NAND Flash device specific information */
+struct fcm_nand {
+	int		bank;       /* Chip select bank number             */
+	unsigned int	base;       /* Chip select base address            */
+	int		pgs;        /* NAND page size                      */
+	int		oobbuf;     /* Pointer to OOB block                */
+	unsigned int	page;       /* Last page written to / read from    */
+	unsigned int	fmr;        /* FCM Flash Mode Register value       */
+	unsigned int	mdr;        /* UPM/FCM Data Register value         */
+	unsigned int	use_mdr;    /* Non zero if the MDR is to be set    */
+	u_char	       *addr;       /* Address of assigned FCM buffer      */
+	unsigned int	read_bytes; /* Number of bytes read during command */
+	unsigned int	index;      /* Pointer to next byte to 'read'      */
+	unsigned int	req_bytes;  /* Number of bytes read if command ok  */
+	unsigned int	req_index;  /* New read index if command ok        */
+	unsigned int	status;     /* status read from LTESR after last op*/
+};
+
+
+/* These map to the positions used by the FCM hardware ECC generator */
+
+/* Small Page FLASH with FMR[ECCM] = 0 */
+static struct nand_oobinfo fcm_oob_sp_eccm0 = { /* TODO */
+	.useecc = MTD_NANDECC_AUTOPL_USR, /* MTD_NANDECC_PLACEONLY, */
+	.eccbytes = 3,
+	.eccpos = {6, 7, 8},
+	.oobfree = { {0, 5}, {9, 7} }
+};
+
+/* Small Page FLASH with FMR[ECCM] = 1 */
+static struct nand_oobinfo fcm_oob_sp_eccm1 = { /* TODO */
+	.useecc = MTD_NANDECC_AUTOPL_USR, /* MTD_NANDECC_PLACEONLY, */
+	.eccbytes = 3,
+	.eccpos = {8, 9, 10},
+	.oobfree = { {0, 5}, {6, 2}, {11, 5} }
+};
+
+/* Large Page FLASH with FMR[ECCM] = 0 */
+static struct nand_oobinfo fcm_oob_lp_eccm0 = {
+	.useecc = MTD_NANDECC_AUTOPL_USR, /* MTD_NANDECC_PLACEONLY, */
+	.eccbytes = 12,
+	.eccpos = {6, 7, 8, 22, 23, 24, 38, 39, 40, 54, 55, 56},
+	.oobfree = { {1, 5}, {9, 13}, {25, 13}, {41, 13}, {57, 7} }
+};
+
+/* Large Page FLASH with FMR[ECCM] = 1 */
+static struct nand_oobinfo fcm_oob_lp_eccm1 = {
+	.useecc = MTD_NANDECC_AUTOPL_USR, /* MTD_NANDECC_PLACEONLY, */
+	.eccbytes = 12,
+	.eccpos = {8, 9, 10, 24, 25, 26, 40, 41, 42, 56, 57, 58},
+	.oobfree = { {1, 7}, {11, 13}, {27, 13}, {43, 13}, {59, 5} }
+};
+
+/*
+ * execute FCM command and wait for it to complete
+ */
+static int fcm_run_command(struct mtd_info *mtd)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+	long long end_tick;
+
+	/* Setup the FMR[OP] to execute without write protection */
+	lbc->fmr = fcm->fmr | 3;
+	if (fcm->use_mdr)
+		lbc->mdr = fcm->mdr;
+
+	FCM_DEBUG(5,"fcm_run_command: fmr= %08X fir= %08X fcr= %08X\n",
+		lbc->fmr, lbc->fir, lbc->fcr);
+	FCM_DEBUG(5,"fcm_run_command: fbar=%08X fpar=%08X fbcr=%08X bank=%d\n",
+		lbc->fbar, lbc->fpar, lbc->fbcr, fcm->bank);
+
+	/* clear event registers */
+	lbc->lteatr = 0;
+	lbc->ltesr |= (LTESR_FCT | LTESR_PAR | LTESR_CC);
+
+	/* execute special operation */
+	lbc->lsor = fcm->bank;
+
+	/* wait for FCM complete flag or timeout */
+	fcm->status = 0;
+	end_tick = usec2ticks(FCM_TIMEOUT_USECS) + get_ticks();
+
+	while (end_tick > get_ticks()) {
+		if (lbc->ltesr & LTESR_CC) {
+			fcm->status = lbc->ltesr &
+					(LTESR_FCT | LTESR_PAR | LTESR_CC);
+			break;
+		}
+	}
+
+	/* store mdr value in case it was needed */
+	if (fcm->use_mdr)
+		fcm->mdr = lbc->mdr;
+
+	fcm->use_mdr = 0;
+
+	FCM_DEBUG(5,"fcm_run_command: stat=%08X mdr= %08X fmr= %08X\n",
+		fcm->status, fcm->mdr, lbc->fmr);
+
+	/* if the operation completed ok then set the read buffer pointers */
+	if (fcm->status == LTESR_CC) {
+		fcm->read_bytes = fcm->req_bytes;
+		fcm->index      = fcm->req_index;
+		return 0;
+	}
+
+	return -1;
+}
+
+/*
+ * Set up the FCM hardware block and page address fields, and the fcm
+ * structure addr field to point to the correct FCM buffer in memory
+ */
+static void set_addr(struct mtd_info *mtd, int column, int page_addr, int oob)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+	int buf_num;
+
+	fcm->page = page_addr;
+
+	lbc->fbar = page_addr >> (this->phys_erase_shift - this->page_shift);
+	if (fcm->pgs) {
+		lbc->fpar = ((page_addr << FPAR_LP_PI_SHIFT) & FPAR_LP_PI) |
+			    ( oob ? FPAR_LP_MS : 0) |
+			      column;
+		buf_num = (page_addr & 1) << 2;
+	} else {
+		lbc->fpar = ((page_addr << FPAR_SP_PI_SHIFT) & FPAR_SP_PI) |
+			    ( oob ? FPAR_SP_MS : 0) |
+			      column;
+		buf_num = page_addr & 7;
+	}
+	fcm->addr = (unsigned char*)(fcm->base + (buf_num * 1024));
+
+	/* for OOB data point to the second half of the buffer */
+	if (oob) {
+		fcm->addr += (fcm->pgs ? 2048 : 512);
+	}
+}
+
+/* not required for FCM */
+static void fcm_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	return;
+}
+
+
+/*
+ * FCM does not support 16 bit data busses
+ */
+static u16 fcm_read_word(struct mtd_info *mtd)
+{
+	printf("fcm_read_word: UNIMPLEMENTED.\n");
+	return 0;
+}
+static void fcm_write_word(struct mtd_info *mtd, u16 word)
+{
+	printf("fcm_write_word: UNIMPLEMENTED.\n");
+}
+
+/*
+ * Write buf to the FCM Controller Data Buffer
+ */
+static void fcm_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+
+	FCM_DEBUG(3,"fcm_write_buf: writing %d bytes starting with 0x%x"
+		    " at %d.\n", len, *((unsigned long*) buf), fcm->index);
+
+	/* If armed catch the address of the OOB buffer so that it can be */
+	/* updated with the real signature after the program comletes */
+	if (!fcm->oobbuf)
+		fcm->oobbuf = (int) buf;
+
+	/* copy the data into the FCM hardware buffer and update the index */
+	memcpy(&(fcm->addr[fcm->index]), buf, len);
+	fcm->index += len;
+	return;
+}
+
+
+/*
+ * FCM does not support individual writes. Instead these are either commands
+ * or data being written, both of which are handled through the cmdfunc
+ * handler.
+ */
+static void fcm_write_byte(struct mtd_info *mtd, u_char byte)
+{
+	printf("fcm_write_byte: UNIMPLEMENTED.\n");
+}
+
+/*
+ * read a byte from either the FCM hardware buffer if it has any data left
+ * otherwise issue a command to read a single byte.
+ */
+static u_char fcm_read_byte(struct mtd_info *mtd)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+	unsigned char byte;
+
+	/* If there are still bytes in the FCM then use the next byte */
+	if(fcm->index < fcm->read_bytes) {
+		byte = fcm->addr[(fcm->index)++];
+		FCM_DEBUG(4,"fcm_read_byte: byte %u (%02X): %d of %d.\n",
+			  byte, byte, fcm->index-1, fcm->read_bytes);
+	} else {
+		/* otherwise issue a command to read 1 byte */
+		lbc->fir = (FIR_OP_RSW << FIR_OP0_SHIFT);
+		fcm->use_mdr = 1;
+		fcm->read_bytes = 0;
+		fcm->index = 0;
+		fcm->req_bytes = 0;
+		fcm->req_index = 0;
+		byte = fcm_run_command(mtd) ? ERR_BYTE : fcm->mdr & 0xff;
+		FCM_DEBUG(4,"fcm_read_byte: byte %u (%02X) from bus.\n",
+			  byte, byte);
+	}
+
+	return byte;
+}
+
+
+/*
+ * Read from the FCM Controller Data Buffer
+ */
+static void fcm_read_buf(struct mtd_info *mtd, u_char* buf, int len)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+	int i;
+	int rest;
+
+	FCM_DEBUG(3,"fcm_read_buf: reading %d bytes.\n", len);
+
+	/* If last read failed then return error bytes */
+	if (fcm->status != LTESR_CC) {
+		/* just keep copying bytes so that the oob works */
+		memcpy(buf, &(fcm->addr[(fcm->index)]), len);
+		fcm->index += len;
+	}
+	else
+	{
+		/* see how much is still in the FCM buffer */
+		i = min(len, (fcm->read_bytes - fcm->index));
+		rest = i - len;
+		len = i;
+
+		memcpy(buf, &(fcm->addr[(fcm->index)]), len);
+		fcm->index += len;
+
+		/* If more data is needed then issue another block read */
+		if (rest) {
+			FCM_DEBUG(3,"fcm_read_buf: getting %d more bytes.\n",
+				    rest);
+			buf += len;
+			lbc->fir = (FIR_OP_RBW << FIR_OP0_SHIFT);
+			set_addr(mtd, 0, 0, 0);
+			lbc->fbcr = rest;
+			fcm->req_bytes = lbc->fbcr;
+			fcm->req_index = 0;
+			fcm->use_mdr = 0;
+			if (!fcm_run_command(mtd))
+				fcm_read_buf(mtd, buf, rest);
+			else
+				memcpy(buf, fcm->addr, rest);
+		}
+	}
+	return;
+}
+
+
+/*
+ * Verify buffer against the FCM Controller Data Buffer
+ */
+static int fcm_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+	int i;
+	int rest;
+
+	FCM_DEBUG(3,"fcm_verify_buf: checking %d bytes starting with 0x%02x.\n",
+		len, *((unsigned long*) buf));
+	/* If last read failed then return error bytes */
+	if (fcm->status != LTESR_CC) {
+		return EFAULT;
+	}
+
+	/* see how much is still in the FCM buffer */
+	i = min(len, (fcm->read_bytes - fcm->index));
+	rest = i - len;
+	len = i;
+
+	if (memcmp(buf,	&(fcm->addr[(fcm->index)]), len)) {
+		return EFAULT;
+	}
+
+	fcm->index += len;
+	if (rest) {
+		FCM_DEBUG(3,"fcm_verify_buf: getting %d more bytes.\n", rest);
+		buf += len;
+		lbc->fir = (FIR_OP_RBW << FIR_OP0_SHIFT);
+		set_addr(mtd, 0, 0, 0);
+		lbc->fbcr = rest;
+		fcm->req_bytes = lbc->fbcr;
+		fcm->req_index = 0;
+		fcm->use_mdr = 0;
+		if (fcm_run_command(mtd))
+			return EFAULT;
+		return fcm_verify_buf(mtd, buf, rest);
+
+	}
+	return 0;
+}
+
+/* this function is called after Program and Erase Operations to
+ * check for success or failure */
+static int fcm_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	struct fcm_nand *fcm = this->priv;
+
+	if (fcm->status != LTESR_CC) {
+		return(0x1); /* Status Read error */
+	}
+
+	/* Use READ_STATUS command, but wait for the device to be ready */
+	fcm->use_mdr = 0;
+	fcm->req_index = 0;
+	fcm->read_bytes = 0;
+	fcm->index = 0;
+	fcm->oobbuf = -1;
+	lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+		   (FIR_OP_RBW << FIR_OP1_SHIFT);
+	lbc->fcr = (NAND_CMD_STATUS << FCR_CMD0_SHIFT);
+	set_addr(mtd, 0, 0, 0);
+	lbc->fbcr = 1;
+	fcm->req_bytes = lbc->fbcr;
+	fcm_run_command(mtd);
+	if (fcm->status != LTESR_CC) {
+		return(0x1); /* Status Read error */
+	}
+	return this->read_byte(mtd);
+}
+
+
+/* cmdfunc send commands to the FCM */
+static void fcm_cmdfunc(struct mtd_info *mtd, unsigned command,
+			int column, int page_addr)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+
+	fcm->use_mdr = 0;
+	fcm->req_index = 0;
+
+	/* clear the read buffer */
+	fcm->read_bytes = 0;
+	if (command != NAND_CMD_PAGEPROG) {
+		fcm->index = 0;
+		fcm->oobbuf = -1;
+	}
+
+	switch (command) {
+	/* READ0 and READ1 read the entire buffer to use hardware ECC */
+	case NAND_CMD_READ1:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_READ1, page_addr:"
+			    " 0x%x, column: 0x%x.\n", page_addr, column);
+		fcm->req_index = column + 256;
+		goto read0;
+	case NAND_CMD_READ0:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_READ0, page_addr:"
+			    " 0x%x, column: 0x%x.\n", page_addr, column);
+		fcm->req_index = column;
+read0:
+		if (fcm->pgs) {
+			lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				   (FIR_OP_CA  << FIR_OP1_SHIFT) |
+				   (FIR_OP_PA  << FIR_OP2_SHIFT) |
+				   (FIR_OP_CW1 << FIR_OP3_SHIFT) |
+				   (FIR_OP_RBW << FIR_OP4_SHIFT);
+		} else {
+			lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				   (FIR_OP_CA  << FIR_OP1_SHIFT) |
+				   (FIR_OP_PA  << FIR_OP2_SHIFT) |
+				   (FIR_OP_RBW << FIR_OP3_SHIFT);
+		}
+		lbc->fcr = (NAND_CMD_READ0     << FCR_CMD0_SHIFT) |
+			   (NAND_CMD_READSTART << FCR_CMD1_SHIFT);
+		lbc->fbcr = 0; /* read entire page to enable ECC */
+		set_addr(mtd, 0, page_addr, 0);
+		fcm->req_bytes = mtd->oobblock + mtd->oobsize;
+		goto write_cmd2;
+	/* READOOB read only the OOB becasue no ECC is performed */
+	case NAND_CMD_READOOB:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_READOOB, page_addr:"
+			    " 0x%x, column: 0x%x.\n", page_addr, column);
+		if (fcm->pgs) {
+			lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				   (FIR_OP_CA  << FIR_OP1_SHIFT) |
+				   (FIR_OP_PA  << FIR_OP2_SHIFT) |
+				   (FIR_OP_CW1 << FIR_OP3_SHIFT) |
+				   (FIR_OP_RBW << FIR_OP4_SHIFT);
+			lbc->fcr = (NAND_CMD_READ0     << FCR_CMD0_SHIFT) |
+				   (NAND_CMD_READSTART << FCR_CMD1_SHIFT);
+		} else {
+			lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				   (FIR_OP_CA  << FIR_OP1_SHIFT) |
+				   (FIR_OP_PA  << FIR_OP2_SHIFT) |
+				   (FIR_OP_RBW << FIR_OP3_SHIFT);
+			lbc->fcr = (NAND_CMD_READOOB << FCR_CMD0_SHIFT);
+		}
+		lbc->fbcr = mtd->oobsize - column;
+		set_addr(mtd, column, page_addr, 1);
+		goto write_cmd1;
+	/* READID must read all 5 possible bytes while CEB is active */
+	case NAND_CMD_READID:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_READID.\n");
+		lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+			   (FIR_OP_UA  << FIR_OP1_SHIFT) |
+			   (FIR_OP_RBW << FIR_OP2_SHIFT);
+		lbc->fcr = (NAND_CMD_READID << FCR_CMD0_SHIFT);
+		lbc->fbcr = 5; /* 5 bytes for manuf, device and exts */
+		fcm->use_mdr = 1;
+		fcm->mdr = 0;
+		goto write_cmd0;
+	/* ERASE1 stores the block and page address */
+	case NAND_CMD_ERASE1:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_ERASE1, page_addr:"
+			    " 0x%x.\n", page_addr);
+		set_addr(mtd, 0, page_addr, 0);
+		goto end;
+	/* ERASE2 uses the block and page address from ERASE1 */
+	case NAND_CMD_ERASE2:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_ERASE2.\n");
+		lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+			   (FIR_OP_PA  << FIR_OP1_SHIFT) |
+			   (FIR_OP_CM1 << FIR_OP2_SHIFT);
+		lbc->fcr = (NAND_CMD_ERASE1 << FCR_CMD0_SHIFT) |
+			   (NAND_CMD_ERASE2 << FCR_CMD1_SHIFT);
+		lbc->fbcr = 0;
+		goto write_cmd1;
+	/* SEQIN sets up the addr buffer and all registers except the length */
+	case NAND_CMD_SEQIN:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_SEQIN/PAGE_PROG, page_addr:"
+			    " 0x%x, column: 0x%x.\n", page_addr, column);
+		if (column == 0) {
+			lbc->fbcr = 0; /* write entire page to enable ECC */
+		} else {
+			lbc->fbcr = 1; /* mark as partial page so no HW ECC */
+		}
+		if (fcm->pgs) {
+			/* always use READ0 for large page devices */
+			lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				   (FIR_OP_CA  << FIR_OP1_SHIFT) |
+				   (FIR_OP_PA  << FIR_OP2_SHIFT) |
+				   (FIR_OP_WB  << FIR_OP3_SHIFT) |
+				   (FIR_OP_CW1 << FIR_OP4_SHIFT);
+			lbc->fcr = (NAND_CMD_SEQIN << FCR_CMD0_SHIFT) |
+				   (NAND_CMD_PAGEPROG << FCR_CMD1_SHIFT);
+			set_addr(mtd, column, page_addr, 0);
+		} else {
+			lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				   (FIR_OP_CM2 << FIR_OP1_SHIFT) |
+				   (FIR_OP_CA  << FIR_OP2_SHIFT) |
+				   (FIR_OP_PA  << FIR_OP3_SHIFT) |
+				   (FIR_OP_WB  << FIR_OP4_SHIFT) |
+				   (FIR_OP_CW1 << FIR_OP5_SHIFT);
+			if (column >= mtd->oobblock) {
+				/* OOB area --> READOOB */
+				column -= mtd->oobblock;
+				lbc->fcr = (NAND_CMD_READOOB << FCR_CMD0_SHIFT)
+					 | (NAND_CMD_PAGEPROG<< FCR_CMD1_SHIFT)
+					 | (NAND_CMD_SEQIN << FCR_CMD2_SHIFT);
+				set_addr(mtd, column, page_addr, 1);
+			} else if (column < 256) {
+				/* First 256 bytes --> READ0 */
+				lbc->fcr = (NAND_CMD_READ0 << FCR_CMD0_SHIFT)
+					 | (NAND_CMD_PAGEPROG<< FCR_CMD1_SHIFT)
+					 | (NAND_CMD_SEQIN << FCR_CMD2_SHIFT);
+				set_addr(mtd, column, page_addr, 0);
+			} else {
+				/* Second 256 bytes --> READ1 */
+				column -= 256;
+				lbc->fcr = (NAND_CMD_READ1 << FCR_CMD0_SHIFT)
+					 | (NAND_CMD_PAGEPROG<< FCR_CMD1_SHIFT)
+					 | (NAND_CMD_SEQIN << FCR_CMD2_SHIFT);
+				set_addr(mtd, column, page_addr, 0);
+			}
+		}
+		goto end;
+	/* PAGEPROG reuses all of the setup from SEQIN and adds the length */
+	case NAND_CMD_PAGEPROG:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_PAGEPROG"
+			    " writing %d bytes.\n",fcm->index);
+		/* if the write did not start at 0 or is not a full page */
+		/* then set the exact length, otherwise use a full page  */
+		/* write so the HW generates the ECC. */
+		if (lbc->fbcr ||
+		   (fcm->index != (mtd->oobblock + mtd->oobsize)))
+			lbc->fbcr = fcm->index;
+		fcm->req_bytes = 0;
+		goto write_cmd2;
+	/* CMD_STATUS must read the status byte while CEB is active */
+	/* Note - it does not wait for the ready line */
+	case NAND_CMD_STATUS:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_STATUS.\n");
+		lbc->fir = (FIR_OP_CM0 << FIR_OP0_SHIFT) |
+			   (FIR_OP_RBW << FIR_OP1_SHIFT);
+		lbc->fcr = (NAND_CMD_STATUS << FCR_CMD0_SHIFT);
+		lbc->fbcr = 1;
+		goto write_cmd0;
+	/* RESET without waiting for the ready line */
+	case NAND_CMD_RESET:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_RESET.\n");
+		lbc->fir = (FIR_OP_CM0 << FIR_OP0_SHIFT);
+		lbc->fcr = (NAND_CMD_RESET << FCR_CMD0_SHIFT);
+		lbc->fbcr = 0;
+		goto write_cmd0;
+	default:
+		printk("fcm_cmdfunc: error, unsupported command.\n");
+		goto end;
+	}
+
+	/* Short cuts fall through to save code */
+ write_cmd0:
+	set_addr(mtd, 0, 0, 0);
+ write_cmd1:
+	fcm->req_bytes = lbc->fbcr;
+ write_cmd2:
+	fcm_run_command(mtd);
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* if we wrote a page then read back the oob to get the ECC */
+	if ((command == NAND_CMD_PAGEPROG) &&
+	    (this->eccmode > NAND_ECC_SOFT) &&
+	    (lbc->fbcr == 0) &&
+	    (fcm->oobbuf != 0) &&
+	    (fcm->oobbuf != -1)) {
+		int i;
+		uint *oob_config;
+		unsigned char *oob_buf;
+
+		i = fcm->page;
+		oob_buf = (unsigned char*) fcm->oobbuf;
+		oob_config = this->autooob->eccpos;
+
+		/* wait for the write to complete and check it passed */
+		if (!(this->waitfunc(mtd, this, FL_WRITING) & 0x01)) {
+			/* read back the OOB */
+			fcm_cmdfunc(mtd, NAND_CMD_READOOB, 0, i);
+			/* if it succeeded then copy the ECC bytes */
+			if (fcm->status == LTESR_CC) {
+				for (i = 0; i < this->eccbytes; i++) {
+					oob_buf[oob_config[i]] =
+						fcm->addr[oob_config[i]];
+				}
+			}
+		}
+	}
+#endif
+
+ end:
+	return;
+}
+
+/*
+ * fcm_enable_hwecc - start ECC generation
+ */
+static void fcm_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	return;
+}
+
+/*
+ * fcm_calculate_ecc - Calculate the ECC bytes
+ * This is done by hardware during the write process, so we use this
+ * to arm the oob buf capture on the next write_buf() call. The ECC bytes
+ * only need to be captured if CONFIG_MTD_NAND_VERIFY_WRITE is defined which
+ * reads back the pages and checks they match the data and oob buffers.
+ */
+static int fcm_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* arm capture of oob buf ptr on next write_buf */
+	fcm->oobbuf = 0;
+#endif
+	return 0;
+}
+
+/*
+ * fcm_correct_data - Detect and correct bit error(s)
+ * The detection and correction is done automatically by the hardware,
+ * if the complete page was read. If the status code is okay then there
+ * was no error, otherwise we return an error code indicating an uncorrectable
+ * error.
+ */
+static int fcm_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
+{
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+
+	/* No errors */
+	if (fcm->status == LTESR_CC)
+		return 0;
+
+	return -1; /* uncorrectable error */
+}
+
+
+
+/*
+ * Dummy scan_bbt to complete setup of the FMR based on NAND size
+ */
+static int fcm_scan_bbt (struct mtd_info *mtd)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+	unsigned int i;
+	unsigned int al;
+
+	if (!fcm) {
+		printk (KERN_ERR "fcm_scan_bbt():" \
+			" Failed to allocate chip specific data structure\n");
+		return -1;
+	}
+
+	/* calculate FMR Address Length field */
+	al = 0;
+	for (i = this->pagemask >> 16; i ; i >>= 8) {
+		al++;
+	}
+
+	/* add to ECCM mode set in fcm_init */
+	fcm->fmr |= 12 << FMR_CWTO_SHIFT |  /* Timeout > 12 mSecs */
+		    al << FMR_AL_SHIFT;
+
+	FCM_DEBUG(1,"fcm_init: nand->options  =   %08X\n", this->options);
+	FCM_DEBUG(1,"fcm_init: nand->numchips = %10d\n", this->numchips);
+	FCM_DEBUG(1,"fcm_init: nand->chipsize = %10d\n", this->chipsize);
+	FCM_DEBUG(1,"fcm_init: nand->pagemask = %10X\n", this->pagemask);
+	FCM_DEBUG(1,"fcm_init: nand->eccmode  = %10d\n", this->eccmode );
+	FCM_DEBUG(1,"fcm_init: nand->eccsize  = %10d\n", this->eccsize );
+	FCM_DEBUG(1,"fcm_init: nand->eccbytes = %10d\n", this->eccbytes);
+	FCM_DEBUG(1,"fcm_init: nand->eccsteps = %10d\n", this->eccsteps);
+	FCM_DEBUG(1,"fcm_init: nand->chip_delay = %8d\n", this->chip_delay);
+	FCM_DEBUG(1,"fcm_init: nand->badblockpos = %7d\n", this->badblockpos);
+	FCM_DEBUG(1,"fcm_init: nand->chip_shift = %8d\n", this->chip_shift);
+	FCM_DEBUG(1,"fcm_init: nand->page_shift = %8d\n", this->page_shift);
+	FCM_DEBUG(1,"fcm_init: nand->phys_erase_shift = %2d\n",
+						      this->phys_erase_shift);
+	FCM_DEBUG(1,"fcm_init: mtd->flags     =   %08X\n", mtd->flags);
+	FCM_DEBUG(1,"fcm_init: mtd->size      = %10d\n", mtd->size);
+	FCM_DEBUG(1,"fcm_init: mtd->erasesize = %10d\n", mtd->erasesize);
+	FCM_DEBUG(1,"fcm_init: mtd->oobblock  = %10d\n", mtd->oobblock);
+	FCM_DEBUG(1,"fcm_init: mtd->oobsize   = %10d\n", mtd->oobsize);
+	FCM_DEBUG(1,"fcm_init: mtd->oobavail  = %10d\n", mtd->oobavail);
+	FCM_DEBUG(1,"fcm_init: mtd->ecctype   = %10d\n", mtd->ecctype);
+	FCM_DEBUG(1,"fcm_init: mtd->eccsize   = %10d\n", mtd->eccsize);
+
+	/* adjust Option Register and ECC to match Flash page size */
+	if (mtd->oobblock == 512)
+		lbc->bank[fcm->bank].or &= ~(OR_FCM_PGS);
+	else if (mtd->oobblock == 2048) {
+		lbc->bank[fcm->bank].or |= OR_FCM_PGS;
+		/* adjust ecc setup if needed */
+		if ( (lbc->bank[fcm->bank].br & BR_DECC) == BR_DECC_CHK_GEN) {
+			mtd->eccsize = 2048;
+			mtd->oobavail -= 9;
+			this->eccmode = NAND_ECC_HW12_2048;
+			this->eccsize = 2048;
+			this->eccbytes += 9;
+			this->eccsteps = 1;
+			this->autooob = (fcm->fmr & FMR_ECCM) ?
+					&fcm_oob_lp_eccm1 : &fcm_oob_lp_eccm0;
+			memcpy(&mtd->oobinfo, this->autooob,
+					sizeof(mtd->oobinfo));
+		}
+	}
+	else {
+		printf("fcm_init: page size %d is not supported\n",
+			mtd->oobblock);
+		return -1;
+	}
+	fcm->pgs = (lbc->bank[fcm->bank].or>>OR_FCM_PGS_SHIFT) & 1;
+
+	if (al > 2) {
+		printf("fcm_init: %d address bytes is not supported\n", al+2);
+		return -1;
+	}
+
+	/* restore default scan_bbt function and call it */
+	this->scan_bbt = nand_default_bbt;
+	return nand_default_bbt(mtd);
+}
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand_new.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for accesing device ready/busy line
+ * - enable_hwecc: function to enable (reset) hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+void board_nand_init(struct nand_chip *nand)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	struct fcm_nand *fcm;
+	unsigned int bank;
+
+	/* Enable FCM detection of timeouts, ECC errors and completion */
+	lbc->ltedr &= ~(LTESR_FCT | LTESR_PAR | LTESR_CC);
+
+	fcm = kmalloc (sizeof(struct fcm_nand), GFP_KERNEL);
+	if (!fcm) {
+		printk (KERN_ERR "board_nand_init():" \
+			" Cannot allocate read buffer data structure\n");
+		return;
+	}
+
+	/* Find which chip select bank is being used for this device */
+	for (bank=0; bank<8; bank++) {
+		if ( (lbc->bank[bank].br & BR_V) &&
+		   ( (lbc->bank[bank].br & BR_MSEL) == BR_MS_FCM ) &&
+		   ( (lbc->bank[bank].br & BR_BA) ==
+		     (lbc->bank[bank].or & OR_FCM_AM &
+			(unsigned int)(nand->IO_ADDR_R) ) ) ) {
+			fcm->bank = bank;
+// TODO			fcm->fmr = FMR_ECCM; /* rest filled in later */
+			fcm->fmr = 0; /* rest filled in later */
+			fcm->read_bytes = 0;
+			fcm->index = 0;
+			fcm->pgs = (lbc->bank[bank].or>>OR_FCM_PGS_SHIFT) & 1;
+			fcm->base = lbc->bank[bank].br & BR_BA;
+			fcm->addr = (unsigned char*) (fcm->base);
+			nand->priv = fcm;
+			fcm->oobbuf = -1;
+			break;
+		}
+	}
+
+	if (!nand->priv) {
+		printk (KERN_ERR "board_nand_init():" \
+			" Could not find matching Chip Select\n");
+		return;
+	}
+
+	/* set up nand options */
+	nand->options = 0;
+	/* set up function call table */
+	nand->hwcontrol = fcm_hwcontrol;
+	nand->waitfunc = fcm_wait;
+	nand->read_byte = fcm_read_byte;
+	nand->write_byte = fcm_write_byte;
+	nand->read_word = fcm_read_word;
+	nand->write_word = fcm_write_word;
+	nand->read_buf = fcm_read_buf;
+	nand->verify_buf = fcm_verify_buf;
+	nand->write_buf = fcm_write_buf;
+	nand->cmdfunc = fcm_cmdfunc;
+	nand->scan_bbt = fcm_scan_bbt;
+
+	/* If CS Base Register selects full hardware ECC then use it */
+	if ( ( (lbc->bank[bank].br & BR_DECC) >> BR_DECC_SHIFT) == 2) {
+		/* put in small page settings and adjust later if needed */
+		nand->eccmode = NAND_ECC_HW3_512;
+		nand->autooob = (fcm->fmr & FMR_ECCM) ?
+				&fcm_oob_sp_eccm1 : &fcm_oob_sp_eccm0;
+		nand->calculate_ecc = fcm_calculate_ecc;
+		nand->correct_data = fcm_correct_data;
+		nand->enable_hwecc = fcm_enable_hwecc;
+	} else {
+		/* otherwise fall back to default software ECC */
+		nand->eccmode = NAND_ECC_SOFT;
+	}
+}
+
+#endif
+#endif
diff -purN /dev/null u-boot.open/doc/README.mpc8313erdb
--- /dev/null	2006-12-22 02:40:20.383302336 +0800
+++ u-boot.open/doc/README.mpc8313erdb	2006-12-26 15:12:28.000000000 +0800
@@ -0,0 +1,108 @@
+Freescale MPC8313ERDB Board
+-----------------------------------------
+
+1.	Board Switches and Jumpers
+
+	SW3 is used to set CFG_RESET_SOURCE.
+	
+	To boot using a 66 MHz crystal from the image at 0xFE000000 in NOR
+	flash, using the Hardware Reset Configuration set on the DIP switches:
+	SW3		SW4
+	+------+	+------+
+	|      |	| **** |
+	| **** |	|      |
+	+------+ ON	+------+ ON
+	  4321		  4321
+	(where the '*' indicates the position of the tab of the switch.)
+
+2.	Memory Map
+2.1.	The memory map looks like this:
+	0x0000_0000	0x07ff_ffff	DDR		128M
+	0x8000_0000	0x8fff_ffff	PCI MEM		256M
+	0x9000_0000	0x9fff_ffff	PCI_MMIO	256M
+	0xe000_0000	0xe00f_ffff	IMMR		1M
+	0xe200_0000	0xe20f_ffff	PCI IO	 	16M
+	0xe280_0000	0xe280_7fff	NAND FLASH	32K
+	0xfe00_0000	0xfe7f_ffff	NOR FLASH	8M
+
+3.	Definitions
+
+3.1	Explanation of NEW definitions in:
+	
+	include/configs/MPC8313ERDB.h
+	
+	CONFIG_MPC83xx		MPC83xx family
+	CONFIG_MPC8313		MPC8313/MPC8311 specific
+	CONFIG_MPC8313ERDB	MPC8313ERDB board specific
+
+4.	Compilation
+
+	Assuming you're using BASH shell:
+	export CROSS_COMPILE=your-cross-compile-prefix
+	cd u-boot
+	make distclean
+	make MPC8313ERDB_config
+	make
+	
+	Flash images is built for loading from the bottom of Flash, 
+	The image location is determined by the TEXT_BASE value 
+	in the board/mpc8313erdb/config.mk file:
+	TEXT_BASE = 0xFE000000 builds a low image.
+
+5.	Downloading and Flashing Images
+
+5.1	Download over ethernet:
+
+	tftp 100000 /tftpboot/u-boot.bin	
+
+5.2	Reflash U-boot Image using U-boot
+
+	=>run burn_uboot
+
+	or
+
+	=>tftp 100000 /tftpboot/u-boot.bin
+	=>protect off fe000000 fe06ffff
+	=>erase fe000000 fe06ffff
+	=>cp.b 10000 fe000000 $filesize
+
+5.3	Downloading and Flashing vsc7385 L2 Switch Image for TSEC0
+	
+	Flash the VSC firmware image to flash address 0xfe7fe000.
+	=>run burn_vscfw 
+
+	Load VSC firmware image to VSC L2 Switch
+	=>run run_vscld
+
+	The following steps are done the same thing.
+	
+	=>tftp 100000 /tftpboot/vsc2bin
+	=>protect off fe7fe000 fe7fffff
+	=>erase fe7fe000 fe7ffffff
+	=>cp.b 100000 fe7fe000 $filesize
+
+	=>tftp 40000 /tftpboot/vsc7385_load.bin
+	=>go 40004
+	
+	Note: The VSC7385 loader program is examples/vsc7385_load/vsc7385_load.bin
+	refer examples/vsc7385_load/Readme.txt for detail 
+
+5.4	Downloading and Booting Linux Kernel
+5.4.1	with nfs fs
+	=>run nfsargs addip addtty
+	=>tftp 200000 kernel_img
+	=>tftp 700000 oft_dtb
+	=>bootm 200000 - 700000
+
+5.4.2	With ramdisk fs
+	=>run ramargs addtty
+	=>tftp 200000 kernel_img
+	=>tftp 400000 ramdisk_img
+	=>tftp 700000 oft_dtb
+	=>bootm 200000 400000 700000
+	
+
+6	Notes
+	The U-Boot is not yet supported booting from NAND flash
+	The console baudrate for MPC8313ERDB is 115200bps.
+	
diff -purN /dev/null u-boot.open/board/mpc8313erdb/config.mk
--- /dev/null	2006-12-22 02:40:20.383302336 +0800
+++ u-boot.open/board/mpc8313erdb/config.mk	2006-12-26 15:12:28.000000000 +0800
@@ -0,0 +1,28 @@
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MPC8313EMDS
+#
+
+TEXT_BASE  =   0xFE000000
diff -purN /dev/null u-boot.open/include/configs/MPC8313ERDB.h
--- /dev/null	2006-12-22 02:40:20.383302336 +0800
+++ u-boot.open/include/configs/MPC8313ERDB.h	2006-12-26 15:12:28.000000000 +0800
@@ -0,0 +1,623 @@
+/*
+ * Copyright (C) Freescale Semiconductor, Inc. 2006.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * History
+ * 20061201: Wilson Lo (Wilson.Lo@freescale.com)
+ *           Initialized 
+ * 20061210: Tanya Jiang (tanya.jiang@freescale.com)
+ *           Code Cleanup
+ */
+/*
+ * mpc8313epb board configuration file
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#undef DEBUG
+
+/*
+ * High Level Configuration Options
+ */
+#define CONFIG_E300		1	/* E300 Family */
+#define CONFIG_MPC83XX		1	/* MPC83XX family */
+#define CONFIG_MPC8313		1	/* MPC8313 specific */
+#define CONFIG_MPC8313ERDB	1	/* MPC8313EVAL board specific */
+
+#define CONFIG_PCI
+
+#define PCI_66M				/* default */
+#ifdef PCI_66M
+#define CONFIG_83XX_CLKIN	66666666	/* in Hz */
+#else
+#define CONFIG_83XX_CLKIN	33333333	/* in Hz */
+#endif
+
+#ifndef CONFIG_SYS_CLK_FREQ
+#ifdef PCI_66M
+#define CONFIG_SYS_CLK_FREQ	66666666
+#else
+#define CONFIG_SYS_CLK_FREQ	33333333
+#endif
+#endif
+
+#define CFG_SCCR		( SCCR_RES \
+				| SCCR_TSEC1CM_1	\
+				| SCCR_TSEC1ON		\
+				| SCCR_TSEC2ON		\
+				| SCCR_ENCCM_3		\
+				| SCCR_USBCM_3		\
+				| SCCR_PCICM		)
+
+#define CONFIG_BOARD_EARLY_INIT_F		/* call board_pre_init */
+#undef  CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_EARLY_INIT_R		/* call board_init */
+#undef  CONFIG_BOARD_EARLY_INIT_R
+
+
+#define CFG_IMMR		0xE0000000
+
+#undef CFG_DRAM_TEST				/* memory test, takes time */
+#define CFG_MEMTEST_START	0x00001000	/* memtest region */
+#define CFG_MEMTEST_END		0x07F00000
+
+/*
+ * DDR Setup
+ */
+#undef CONFIG_SPD_EEPROM		/* use SPD EEPROM for DDR setup*/
+
+#define CFG_DDR_BASE		0x00000000	/* DDR is system memory*/
+#define CFG_SDRAM_BASE		CFG_DDR_BASE
+#define CFG_DDR_SDRAM_BASE	CFG_DDR_BASE
+#undef  CONFIG_DDR_2T_TIMING
+
+#if defined(CONFIG_SPD_EEPROM)
+/*
+ * Determine DDR configuration from I2C interface.
+ */
+#define SPD_EEPROM_ADDRESS	0x51		/* DDR DIMM */
+#else
+/*
+ * Manually set up DDR parameters
+ * 256 MByte SODIMM - Micron MT4HTF3264HY-40EB4, 256MB, DDR2, 400, CL3
+ * only using 64 data bits of 128 bit wide DIMM
+ */
+#define CFG_DDR_SIZE		128		/* MB */
+#define CFG_DDR_CONFIG		( CSCONFIG_EN | CSCONFIG_AP \
+				| 0x00040000 /* TODO */ \
+				| CSCONFIG_ROW_BIT_13 | CSCONFIG_COL_BIT_10 )
+				/* 0x80840102 */
+#define CFG_DDRCDR		( DDRCDR_EN \
+				| DDRCDR_PZ_NOMZ \
+				| DDRCDR_NZ_NOMZ \
+				| DDRCDR_M_ODR )
+				/* 0x73000002 TODO ODR & DRN ? */
+
+#define CFG_DDR_CLK_CNTL	DDR_SDRAM_CLK_CNTL_CLK_ADJUST_05
+				/*0x02000000*/
+#define CFG_DDR_TIMING_3	0x00000000
+#define CFG_DDR_TIMING_0	( ( 0 << TIMING_CFG0_RWT_SHIFT ) \
+				| ( 0 << TIMING_CFG0_WRT_SHIFT ) \
+				| ( 0 << TIMING_CFG0_RRT_SHIFT ) \
+				| ( 0 << TIMING_CFG0_WWT_SHIFT ) \
+				| ( 2 << TIMING_CFG0_ACT_PD_EXIT_SHIFT ) \
+				| ( 2 << TIMING_CFG0_PRE_PD_EXIT_SHIFT ) \
+				| ( 8 << TIMING_CFG0_ODT_PD_EXIT_SHIFT ) \
+				| ( 2 << TIMING_CFG0_MRS_CYC_SHIFT ) )
+				/* 0x00220802 */
+#define CFG_DDR_TIMING_1	( ( 3 << TIMING_CFG1_PRETOACT_SHIFT ) \
+				| ( 9 << TIMING_CFG1_ACTTOPRE_SHIFT ) \
+				| ( 3 << TIMING_CFG1_ACTTORW_SHIFT ) \
+				| ( 5 << TIMING_CFG1_CASLAT_SHIFT ) \
+				| (13 << TIMING_CFG1_REFREC_SHIFT ) \
+				| ( 3 << TIMING_CFG1_WRREC_SHIFT ) \
+				| ( 2 << TIMING_CFG1_ACTTOACT_SHIFT ) \
+				| ( 2 << TIMING_CFG1_WRTORD_SHIFT ) )
+				/* 0x3935d322 */
+#define CFG_DDR_TIMING_2	( ( 0 << TIMING_CFG2_ADD_LAT_SHIFT ) \
+				| (31 << TIMING_CFG2_CPO_SHIFT ) \
+				| ( 2 << TIMING_CFG2_WR_LAT_DELAY_SHIFT ) \
+				| ( 2 << TIMING_CFG2_RD_TO_PRE_SHIFT ) \
+				| ( 2 << TIMING_CFG2_WR_DATA_DELAY_SHIFT ) \
+				| ( 3 << TIMING_CFG2_CKE_PLS_SHIFT ) \
+				| (10 << TIMING_CFG2_FOUR_ACT_SHIFT) )
+				/* 0x0f9048ca */ /* P9-45,may need tuning */
+#define CFG_DDR_INTERVAL	( ( 800 << SDRAM_INTERVAL_REFINT_SHIFT ) \
+				| ( 100 << SDRAM_INTERVAL_BSTOPRE_SHIFT ) )
+				/* 0x03200064 */
+#if defined(CONFIG_DDR_2T_TIMING)
+#define CFG_SDRAM_CFG		( SDRAM_CFG_SREN \
+				| 3 << SDRAM_CFG_SDRAM_TYPE_SHIFT \
+				| SDRAM_CFG_2T_EN \
+				| SDRAM_CFG_DBW_32 )
+#else
+#define CFG_SDRAM_CFG		( SDRAM_CFG_SREN \
+				| 3 << SDRAM_CFG_SDRAM_TYPE_SHIFT \
+				| SDRAM_CFG_DBW_32 )
+				/* 0x43080000 */
+#endif
+#define CFG_SDRAM_CFG2		0x00401000;
+/* set burst length to 8 for 32-bit data path */
+#define CFG_DDR_MODE		( ( 0x4440 << SDRAM_MODE_ESD_SHIFT ) \
+				| ( 0x0232 << SDRAM_MODE_SD_SHIFT ) )
+				/* 0x44400232 */
+#define CFG_DDR_MODE_2		0x8000C000;
+#endif
+
+/*
+ * FLASH on the Local Bus
+ */
+#define CFG_FLASH_CFI				/* use the Common Flash Interface */
+#define CFG_FLASH_CFI_DRIVER			/* use the CFI driver */
+#define CFG_FLASH_BASE		0xFE000000	/* start of FLASH   */
+#define CFG_FLASH_SIZE		8		/* flash size in MB */
+#define CFG_FLASH_EMPTY_INFO			/* display empty sectors */
+#define CFG_FLASH_USE_BUFFER_WRITE		/* buffer up multiple bytes */
+
+#define CFG_BR0_PRELIM		(CFG_FLASH_BASE |    /* flash Base address */ \
+				(2 << BR_PS_SHIFT) | /* 16 bit port size */ \
+				BR_V)		     /* valid */
+#define CFG_OR0_PRELIM		( 0xFF000000         /* 16 MByte */ \
+				| OR_GPCM_XACS \
+				| OR_GPCM_SCY_9 \
+				| OR_GPCM_EHTR \
+				| OR_GPCM_EAD )
+				/* 0xFF006FF7	TODO SLOW 16 MB flash size */
+#define CFG_LBLAWBAR0_PRELIM	CFG_FLASH_BASE	/* window base at flash base */
+#define CFG_LBLAWAR0_PRELIM	0x80000017	/* 16 MB window size */
+
+#define CFG_MAX_FLASH_BANKS	1		/* number of banks */
+#define CFG_MAX_FLASH_SECT	135		/* sectors per device */
+
+#undef CFG_FLASH_CHECKSUM
+#define CFG_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CFG_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CFG_MONITOR_BASE	TEXT_BASE	/* start of monitor */
+
+#if (CFG_MONITOR_BASE < CFG_FLASH_BASE)
+#define CFG_RAMBOOT
+#else
+#undef  CFG_RAMBOOT
+#endif
+
+#define CFG_INIT_RAM_LOCK	1
+#define CFG_INIT_RAM_ADDR	0xFD000000	/* Initial RAM address */
+#define CFG_INIT_RAM_END	0x1000		/* End of used area in RAM*/
+
+#define CFG_GBL_DATA_SIZE	0x100		/* num bytes initial data */
+#define CFG_GBL_DATA_OFFSET	(CFG_INIT_RAM_END - CFG_GBL_DATA_SIZE)
+#define CFG_INIT_SP_OFFSET	CFG_GBL_DATA_OFFSET
+
+#define CFG_MONITOR_LEN		(256 * 1024)	/* Reserve 256 kB for Mon */
+#define CFG_MALLOC_LEN		(128 * 1024)	/* Reserved for malloc */
+
+/*
+ * Local Bus LCRR and LBCR regs
+ */
+#define CFG_LCRR	LCRR_EADC_1 | LCRR_CLKDIV_2	/* 0x00010002 */
+#define CFG_LBC_LBCR	( 0x00040000 /* TODO */ \
+			| (0xFF << LBCR_BMT_SHIFT) \
+			| 0xF )	/* 0x0004ff0f */
+
+#define CFG_LBC_MRTPR	0x20000000  /*TODO */  /* LB refresh timer prescal, 266MHz/32 */
+
+/* drivers/nand/nand.c */
+#define CFG_NAND_BASE		0xE2800000 /* 0xF0000000 */
+#define CFG_MAX_NAND_DEVICE	1
+#define NAND_MAX_CHIPS		1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+
+#define CFG_BR1_PRELIM		( CFG_NAND_BASE \
+				| (2<<BR_DECC_SHIFT) /* Use HW ECC */ \
+				| BR_PS_8            /* Port Size = 8 bit */ \
+				| BR_MS_FCM          /* MSEL = FCM */ \
+				| BR_V )             /* valid */
+#define CFG_OR1_PRELIM		( 0xFFFF8000	/* length 32K */ \
+				| OR_FCM_BCTLD \
+				| OR_FCM_CSCT \
+				| OR_FCM_CST \
+				| OR_FCM_CHT \
+				| OR_FCM_SCY_1 \
+				| OR_FCM_TRLX \
+				| OR_FCM_EHTR )
+				/* 0xFFFF8396 */
+#define CFG_LBLAWBAR1_PRELIM	CFG_NAND_BASE
+#define CFG_LBLAWAR1_PRELIM	0x8000000E	/* 32KB  */
+
+#define CFG_VSC7385_BASE	0xF0000000
+
+#define CONFIG_VSC7385_ENET			/* VSC7385 ethernet support */
+#define CFG_BR2_PRELIM		0xf0000801	/* VSC7385 Base address */
+#define CFG_OR2_PRELIM		0xfffe09ff	/* VSC7385, 128K bytes*/
+#define CFG_LBLAWBAR2_PRELIM	CFG_VSC7385_BASE/* Access window base at VSC7385 base */
+#define CFG_LBLAWAR2_PRELIM	0x80000010	/* Access window size 128K */
+
+/* local bus read write buffer mapping */
+#define CFG_BR3_PRELIM		0xFA000801	/* map at 0xFA000000 */
+#define CFG_OR3_PRELIM		0xFFFF8FF7	/* 32kB */
+#define CFG_LBLAWBAR3_PRELIM	0xFA000000
+#define CFG_LBLAWAR3_PRELIM	0x8000000E	/* 32KB  */
+
+/* pass open firmware flat tree */
+#define CONFIG_OF_FLAT_TREE	1
+#define CONFIG_OF_BOARD_SETUP	1
+
+/* maximum size of the flat tree (8K) */
+#define OF_FLAT_TREE_MAX_SIZE	8192
+
+#define OF_CPU			"PowerPC,8313@0"
+#define OF_SOC			"soc8313@e0000000"
+#define OF_TBCLK		(bd->bi_busfreq / 4)
+#define OF_STDOUT_PATH		"/soc8313@e0000000/serial@4500"
+
+/*
+ * Serial Port
+ */
+#define CONFIG_CONS_INDEX	1
+#undef CONFIG_SERIAL_SOFTWARE_FIFO
+#define CFG_NS16550
+#define CFG_NS16550_SERIAL
+#define CFG_NS16550_REG_SIZE	1
+#define CFG_NS16550_CLK		get_bus_freq(0)
+
+#define CFG_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400,115200}
+
+#define CFG_NS16550_COM1	(CFG_IMMR+0x4500)
+#define CFG_NS16550_COM2	(CFG_IMMR+0x4600)
+
+/* Use the HUSH parser */
+#define CFG_HUSH_PARSER
+#ifdef  CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "> "
+#endif
+
+/* I2C */
+#define CONFIG_HARD_I2C			/* I2C with hardware support*/
+#undef CONFIG_SOFT_I2C			/* I2C bit-banged */
+#define CONFIG_FSL_I2C
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_CMD_TREE
+#define CFG_I2C_SPEED		400000	/* I2C speed and slave address */
+#define CFG_I2C_SLAVE		0x7F
+#define CFG_I2C_NOPROBES	{0x69}	/* Don't probe these addrs */
+#define CFG_I2C_OFFSET		0x3000
+#define CFG_I2C2_OFFSET		0x3100
+
+/* TSEC */
+#define CFG_TSEC1_OFFSET	0x24000
+#define CFG_TSEC1		(CFG_IMMR+CFG_TSEC1_OFFSET)
+#define CFG_TSEC2_OFFSET	0x25000
+#define CFG_TSEC2		(CFG_IMMR+CFG_TSEC2_OFFSET)
+#define CONFIG_NET_MULTI
+
+/*
+ * General PCI
+ * Addresses are mapped 1-1.
+ */
+#define CFG_PCI1_MEM_BASE	0x80000000	
+#define CFG_PCI1_MEM_PHYS	CFG_PCI1_MEM_BASE	
+#define CFG_PCI1_MEM_SIZE	0x10000000	/* 256M */
+#define CFG_PCI1_MMIO_BASE	0x90000000	
+#define CFG_PCI1_MMIO_PHYS	CFG_PCI1_MMIO_BASE	
+#define CFG_PCI1_MMIO_SIZE	0x10000000	/* 256M */
+#define CFG_PCI1_IO_BASE	0x00000000		
+#define CFG_PCI1_IO_PHYS	0xE2000000		
+#define CFG_PCI1_IO_SIZE	0x00100000	/* 1M */	
+
+#ifdef CONFIG_PCI
+
+#define CONFIG_PCI_PNP		/* do pci plug-and-play */
+
+#undef CONFIG_E1000
+#undef CONFIG_EEPRO100
+#undef CONFIG_TULIP
+
+#undef CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+
+#if !defined(CONFIG_PCI_PNP)
+	#define PCI_ENET0_IOADDR	0xFIXME
+	#define PCI_ENET0_MEMADDR	0xFIXME
+	#define PCI_IDSEL_NUMBER	0x0c	/* slot0->3(IDSEL)=12->15 */
+#endif
+
+#define CFG_PCI_SUBSYS_VENDORID 0x1057	/* Motorola */
+
+#endif	/* CONFIG_PCI */
+
+/*
+ * TSEC configuration
+ */
+#define CONFIG_TSEC_ENET		/* TSEC ethernet support */
+
+#if defined(CONFIG_TSEC_ENET)
+
+#ifndef CONFIG_NET_MULTI
+#define CONFIG_NET_MULTI	1
+#endif
+
+#define CONFIG_GMII		1	/* MII PHY management */
+#define CONFIG_MPC83XX_TSEC1	1
+
+#define CONFIG_MPC83XX_TSEC1_NAME	"TSEC0"
+#define CONFIG_MPC83XX_TSEC2	1
+#define CONFIG_MPC83XX_TSEC2_NAME	"TSEC1"
+#define TSEC1_PHY_ADDR		0x1c
+#define TSEC2_PHY_ADDR		4
+#define TSEC1_PHYIDX		0
+#define TSEC2_PHYIDX		0
+
+/* Options are: TSEC[0-1] */
+#define CONFIG_ETHPRIME		"TSEC1"
+
+#endif	/* CONFIG_TSEC_ENET */
+
+/*
+ * Configure on-board RTC
+ */
+#define CONFIG_RTC_DS1337
+#define CFG_I2C_RTC_ADDR	0x68	/* at address 0x68	*/
+
+/*
+ * Environment
+ */
+#ifndef CFG_RAMBOOT
+	#define CFG_ENV_IS_IN_FLASH	1
+	#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + 0x50000)
+	#define CFG_ENV_SECT_SIZE	0x10000	/* 128K(one sector) for env */
+	#define CFG_ENV_SIZE		0x2000
+
+/* Address and size of Redundant Environment Sector */
+#else
+	#define CFG_ENV_IS_NOWHERE	1	/* Store ENV in memory only */
+	#define CFG_ENV_ADDR		(CFG_MONITOR_BASE - 0x1000)
+	#define CFG_ENV_SIZE		0x2000
+#endif
+
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download */
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
+
+#define CFG_BASE_COMMANDS	( CONFIG_CMD_DFL	\
+				| CFG_CMD_PING		\
+				| CFG_CMD_DHCP		\
+				| CFG_CMD_I2C		\
+				| CFG_CMD_MII		\
+				| CFG_CMD_DATE		\
+				| CFG_CMD_PCI		\
+				| CFG_CMD_NAND)
+
+#define CFG_RAMBOOT_COMMANDS	( CFG_BASE_COMMANDS &	\
+				~( CFG_CMD_ENV | CFG_CMD_LOADS ))
+
+#if defined(CFG_RAMBOOT)
+#if defined(CONFIG_PCI)
+#define CONFIG_COMMANDS	(CFG_RAMBOOT_COMMANDS | CFG_CMD_PCI)
+#else
+#define CONFIG_COMMANDS	(CFG_RAMBOOT_COMMANDS)
+#endif
+#else
+#if defined(CONFIG_PCI)
+#define  CONFIG_COMMANDS	(CFG_BASE_COMMANDS | CFG_CMD_PCI)
+#else
+#define  CONFIG_COMMANDS	(CFG_BASE_COMMANDS)
+#endif
+#endif
+
+#include <cmd_confdefs.h>
+
+#undef CONFIG_WATCHDOG			/* watchdog disabled */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CFG_LONGHELP			/* undef to save memory */
+#define CFG_LOAD_ADDR	0x2000000	/* default load address */
+#define CFG_PROMPT	"=> "		/* Monitor Command Prompt */
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+	#define CFG_CBSIZE	1024	/* Console I/O Buffer Size */
+#else
+	#define CFG_CBSIZE	256	/* Console I/O Buffer Size */
+#endif
+
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define CFG_MAXARGS	16		/* max number of command args */
+#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size */
+#define CFG_HZ		1000		/* decrementer freq: 1ms ticks */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 8 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CFG_BOOTMAPSZ	(8 << 20)	/* Initial Memory map for Linux*/
+
+/* Cache Configuration */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CFG_CACHELINE_SHIFT	5	/*log base 2 of the above value*/
+#endif
+
+#define CFG_RCWH_PCIHOST 0x80000000 /* PCIHOST  */
+
+/* 66 MHz OSC
+ Boot high 62040000 84606c00
+ Boot Low  62040000 80606c00
+*/
+#ifdef PCI_66M 
+/* 66MHz IN, 133MHz CSB, 266 DDR, 266 CORE */
+#define CFG_HRCW_LOW (\
+	HRCWL_LCL_BUS_TO_SCB_CLK_1X1 |\
+	HRCWL_INIT |\
+	HRCWL_DDR_TO_SCB_CLK_2X1 |\
+	HRCWL_CSB_TO_CLKIN_2X1 |\
+	HRCWL_CORE_TO_CSB_2X1)
+#else
+#if 1 /* 33MHz IN, 166MHz CSB, 333 DDR, 333 CORE */
+#define CFG_HRCW_LOW (\
+	HRCWL_LCL_BUS_TO_SCB_CLK_1X1 |\
+	HRCWL_INIT |\
+	HRCWL_DDR_TO_SCB_CLK_2X1 |\
+	HRCWL_CSB_TO_CLKIN_5X1 |\
+	HRCWL_CORE_TO_CSB_2X1)
+#else /* 33MHz IN, 133MHz CSB, 266 DDR, 266 CORE */
+#define CFG_HRCW_LOW (\
+	HRCWL_LCL_BUS_TO_SCB_CLK_1X1 |\
+	HRCWL_INIT |\
+	HRCWL_DDR_TO_SCB_CLK_2X1 |\
+	HRCWL_CSB_TO_CLKIN_4X1 |\
+	HRCWL_CORE_TO_CSB_2X1)
+#endif
+#endif /* PCI_66M */
+
+/* HRCWH: 0xa0606C00 */
+#define CFG_HRCW_HIGH (\
+	HRCWH_PCI_HOST |\
+	HRCWH_PCI1_ARBITER_ENABLE |\
+	HRCWH_CORE_ENABLE |\
+	HRCWH_FROM_0X00000100 |\
+	HRCWH_BOOTSEQ_DISABLE |\
+	HRCWH_SW_WATCHDOG_DISABLE |\
+	HRCWH_ROM_LOC_LOCAL_16BIT |\
+	HRCWH_RL_EXT_LEGACY |\
+	HRCWH_TSEC1M_IN_RGMII |\
+	HRCWH_TSEC2M_IN_RGMII |\
+	HRCWH_BIG_ENDIAN |\
+	HRCWH_LALE_NORMAL)
+/* System IO Config */
+#define CFG_SICRH	(SICRH_TSOBI1 | SICRH_TSOBI2) /* RGMII */
+#define CFG_SICRL	SICRL_USBDR /* Enable Internal USB Phy  */
+
+#define CFG_HID0_INIT	0x000000000
+#define CFG_HID0_FINAL	HID0_ENABLE_MACHINE_CHECK
+
+#define CFG_HID2 HID2_HBE
+
+/* DDR @ 0x00000000 */
+#define CFG_IBAT0L	(CFG_SDRAM_BASE | BATL_PP_10 | BATL_MEMCOHERENCE)
+#define CFG_IBAT0U	(CFG_SDRAM_BASE | BATU_BL_256M | BATU_VS | BATU_VP)
+
+/* PCI @ 0x80000000 */
+#ifdef CONFIG_PCI
+#define CFG_IBAT1L	(CFG_PCI1_MEM_BASE | BATL_PP_10 | BATL_MEMCOHERENCE)
+#define CFG_IBAT1U	(CFG_PCI1_MEM_BASE | BATU_BL_256M | BATU_VS | BATU_VP)
+#define CFG_IBAT2L	(CFG_PCI1_MMIO_BASE | BATL_PP_10 | BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CFG_IBAT2U	(CFG_PCI1_MMIO_BASE | BATU_BL_256M | BATU_VS | BATU_VP)
+#else
+#define CFG_IBAT1L	(0)
+#define CFG_IBAT1U	(0)
+#define CFG_IBAT2L	(0)
+#define CFG_IBAT2U	(0)
+#endif
+
+/* PCI2 not supported on 8313 */
+#define CFG_IBAT3L	(0)
+#define CFG_IBAT3U	(0)
+#define CFG_IBAT4L	(0)
+#define CFG_IBAT4U	(0)
+
+/* IMMRBAR @ 0xE0000000, PCI IO @ 0xE2000000 & BCSR @ 0xE2400000 */
+#define CFG_IBAT5L	(CFG_IMMR | BATL_PP_10 | BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CFG_IBAT5U	(CFG_IMMR | BATU_BL_256M | BATU_VS | BATU_VP)
+
+/* SDRAM @ 0xF0000000, stack in DCACHE 0xFDF00000 & FLASH @ 0xFE000000 */
+#define CFG_IBAT6L	(0xF0000000 | BATL_PP_10 | BATL_MEMCOHERENCE)
+#define CFG_IBAT6U	(0xF0000000 | BATU_BL_256M | BATU_VS | BATU_VP)
+
+#define CFG_IBAT7L	(0)
+#define CFG_IBAT7U	(0)
+
+#define CFG_DBAT0L	CFG_IBAT0L
+#define CFG_DBAT0U	CFG_IBAT0U
+#define CFG_DBAT1L	CFG_IBAT1L
+#define CFG_DBAT1U	CFG_IBAT1U
+#define CFG_DBAT2L	CFG_IBAT2L
+#define CFG_DBAT2U	CFG_IBAT2U
+#define CFG_DBAT3L	CFG_IBAT3L
+#define CFG_DBAT3U	CFG_IBAT3U
+#define CFG_DBAT4L	CFG_IBAT4L
+#define CFG_DBAT4U	CFG_IBAT4U
+#define CFG_DBAT5L	CFG_IBAT5L
+#define CFG_DBAT5U	CFG_IBAT5U
+#define CFG_DBAT6L	CFG_IBAT6L
+#define CFG_DBAT6U	CFG_IBAT6U
+#define CFG_DBAT7L	CFG_IBAT7L
+#define CFG_DBAT7U	CFG_IBAT7U
+
+/*
+ * Internal Definitions
+ *
+ * Boot Flags
+ */
+#define BOOTFLAG_COLD	0x01	/* Normal Power-On: Boot from FLASH */
+#define BOOTFLAG_WARM	0x02	/* Software reboot */
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed of kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_ENV_OVERWRITE
+
+#if defined(CONFIG_TSEC_ENET)
+#define CONFIG_ETHADDR		00:04:9f:ef:23:33
+#define CONFIG_HAS_ETH1
+#define CONFIG_ETH1ADDR		00:E0:0C:00:7E:21
+#endif
+
+#define CONFIG_IPADDR		10.193.20.184
+#define CONFIG_SERVERIP		10.193.20.61
+
+#define CONFIG_HOSTNAME		mpc8313erdb
+#define CONFIG_ROOTPATH		/tftpboot/10.193.20.184
+#define CONFIG_BOOTFILE		/tftpboot/uImage
+
+
+#define CONFIG_LOADADDR		200000	/* default location for tftp and bootm */
+#define CONFIG_BOOTDELAY	10	/* -1 disables auto-boot */
+#define CONFIG_BAUDRATE		115200
+
+#define	CONFIG_EXTRA_ENV_SETTINGS						\
+	"load_uboot=tftp 100000 /tftpboot/u-boot.bin\0"				\
+	"update_uboot=protect off fe000000 fe06ffff; "				\
+		"era fe000000 fe06ffff; cp.b 100000 fe000000 $filesize\0"	\
+	"burn_uboot=run load_uboot;run update_uboot\0"				\
+	"netdev=eth1\0"								\
+	"nfsargs=setenv bootargs root=/dev/nfs rw "				\
+		"nfsroot=${serverip}:${rootpath}\0"				\
+	"ramargs=setenv bootargs root=/dev/ram rw\0"				\
+	"addip=setenv bootargs ${bootargs} "					\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}"		\
+		":${hostname}:${netdev}:off panic=1\0"				\
+	"addtty=setenv bootargs ${bootargs} console=ttyS0,${baudrate}\0"	\
+	"load_vscfw=tftp 100000 /tftpboot/vsc2bin\0"				\
+	"update_vscfw=protect off fe7fe000 fe7fffff;"				\
+		"erase fe7fe000 fe7fffff; cp.b 100000 fe7fe000 $filesize\0"	\
+	"burn_vscfw=run load_vscfw; run update_vscfw\0"				\
+	"run_vscld=tftp 40000 /tftpboot/vsc7385_load.bin;" 			\
+			"go 40004 \0"						\
+	""
+#endif	/* __CONFIG_H */
